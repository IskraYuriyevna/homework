1. 奇偶校验
    * 根据进制将数字转为多位二进制，如八进制就是三位二进制数字，而16进制就是4位二进制数字，然后按照其中的1的数量加上最后一位，奇数为1,偶数为0.

    1. В оперативном запоминающем（随机存储器） устройстве 16-разрядного（16位） компьютера используется контроль целостности（完整性） данных по четности（奇偶性）. Описать возможную структуру ячейки памяти и ее побитовое（按位） содержимое для случая хранения в машинном слове восьмеричного（八进制的） числа (17735)8.
    * 答案:(17735)8. Посчитаем число двоичных единиц в каждой восьмеричной цифре: 1 + 3 + 3 + 2 + 2 = 11, число нечетное. Тогда бит паритета равен 1. Структура ячейки памяти: 16 бит данных (0001111111011101) + 1 бит паритета (1), который вычисляется как сумма по модулю 2 (XOR) всех битов данных. 

    4. В оперативном запоминающем устройстве 16-разрядного компьютера используется контроль целостности данных по четности. Описать возможную структуру ячейки памяти и ее побитовое содержимое для случая хранения в машинном слове четверичного（四进制的） числа (1033231)4.
    * 答案：(1033231)4. Посчитаем число двоичных единиц в каждой четверичной цифре: 1 + 0 + 2 + 2 + 1 + 2 + 1 = 9, число нечетное. Тогда бит паритета равен 1. Структура ячейки памяти: 16 бит данных (0001001111101101) + 1 бит паритета (1), который вычисляется как сумма по модулю 2 (XOR) всех битов данных. 

    6. В оперативном запоминающем устройстве 32-разрядного компьютера используется контроль целостности данных по нечетности. Описать возможную структуру ячейки памяти и ее побитовое содержимое для случая хранения в машинном слове 16-ичного числа (FF001077)16
    * 答案：(FF001077)16. Посчитаем число двоичных единиц в каждой ненулевой 16-ичной цифре: 4 + 4 + 1 + 3 + 3 = 15, число нечетное. Тогда бит паритета равен 1. Структура ячейки памяти: 32бита данных (11111111000000000001000001110111) + 1 бит паритета (1), который вычисляется как сумма по модулю 2 (XOR) всех битов данных.

2. RAM地址分层
    * 首先按照给出的进制转换为二进制数，然后根据по n банкам，计算出a=log2(n)，最后a位二进制数就是答案，并且转化为十进制。
    * 也就是说по 16 банкам就是最后4位，по 8 банкам就是最后3位。

    1. Пусть дано восьмеричное число (173357)8, являющееся адресом оперативной памяти, расслоенной по 16 банкам（内存块）. Банку с каким номером принадлежит（属于） заданный адрес?
    * 答案：(173357)8. В схеме расслоения памяти последовательные адреса размещаются в последовательных банках памяти. При 16 банках памяти за номер банка будут отвечать младшие 4 бита адреса. Они равны 1111, то есть 15. Ответ: банк памяти 15. (нумерация банков памяти с 0)

    5. Пусть дано четверичное число (323112)4, являющееся адресом оперативной памяти, расслоенной по 8 банкам. Банку с каким номером принадлежит заданный адрес?
    * 答案：(323112)4. В схеме расслоения памяти последовательные адреса размещаются в последовательных банках памяти. При 8 банках памяти за номер банка будут отвечать младшие 3 бита адреса. Они равны 110, то есть 6. Ответ: банк памяти 6. (нумерация банков памяти с 0)

    6. Пусть дано 16-ичное число (FAD1D31A)16, являющееся адресом оперативной памяти, расслоенной по 16 банкам. Банку с каким номером принадлежит заданный адрес?
    * 答案：(FAD1D31A)16. В схеме расслоения памяти последовательные адреса размещаются в последовательных банках памяти. При 16 банках памяти за номер банка будет отвечать младшая 16-ичная цифра адреса. Она равна A_16, то есть 10. Ответ: банк памяти 10. (нумерация банков памяти с 0)

3. IP地址的结构
    * IP地址的ABCDE五个类：全部都是32位二进制数，全部背下来，题目只会问ABC型
        * A: 0 + 8位网络号 + 24位主机号
        * B: 10 + 14位网络号 + 16位主机号
        * C: 110 + 21位网络号 + 8位主机号 
        * D: 1110 + 28位多播地址
        * E: 1111 + 28位保留到今后使用

    1. Дан 32-разрядный IP адрес, имеющий в восьмеричном представлении вид: (23171171543)8. Определить: к какому классу относится данный IP адрес; номер сети (в восьмеричном представлении), к которой относится IP адрес
    * 答案：(23171171543)8. 
        10011001111001001111001101100011_2
        Старшие биты адреса: 10, это сеть класса B. 
        Номер сети – следующие 14 бит, номер хоста –оставшиеся 16 бит. Тогда номер сети: 
        01100111100100_2 = 14744_8.

    4. Дан 32-разрядный IP адрес, имеющий в 16-ичном представлении вид: (DF00BE20)16. Определить: к какому классу относится данный IP адрес; номер сети (в 16-ичном представлении), и десятичный номер хоста в сети, к которой относится IP адрес
    * 答案：(DF00BE20)16. 
        11011111000000001011111000100000_2
        Старшие биты адреса: 110, это сеть класса С. 
        Номер сети – следующие 21 бит, номер хоста –оставшиеся 8 бит. Тогда номер сети: 
        111110000000010111110_2 = 1F00BE_16, а номер хоста – 32_10 (20_16).

4. 进程调度，问代码输出
    * fork之后的内容所有进程都会有，父进程和子进程都有可能先执行，如果没有判断pid,那么第二次fork会产生两个新进程：父进程的第二子和子进程的第一子。
    * 如果父进程先结束（比如exit(0)）了，子进程将会变成孤儿进程，其ppid为1
    * getppid();是获得父进程的进程号，getpid();是获得当前进程的进程号

    1. Пусть процесс с PID A породил два сыновьих процесса с PID-ами B и C:
    ```c
    int main(int argc, char **argv) //PID = A
    {
        if (fork() == 0){ //PID = B
            printf ("%d %d\n", getppid(), getpid());
            exit(0);
        }
        if (fork() == 0){ //PID = C
            printf ("%d\n", getpid());
            exit(0); 
        }
        return 0; 
    }

    ```
    Считаем, что printf работает атомарно и обращения ко всем системным вызовам успешно отрабатывают. Перечислить все возможные комбинации значений, которые могут быть выведены на стандартное устройство вывода в результате выполнения данной программы. 
    我们假设printf以原子方式工作，并且成功处理所有系统调用（也就是fork，pipe和内存分配这些都不会以异常退出）。列出 可以作为运行此程序的结果 输出到标准输出设备 的值 的所有可能组合。
    * 答案：
    ```c
    A B
    C
    либо
    1 B
    C
    либо 
    C
    A B
    либо 
    C
    1 B
    ```

    4. Пусть процесс с PID 4123 породил два сыновних процесса с PID-ами 4124 и 4125:
    ```
    int main(int argc, char **argv) //PID = 4123 
    {
        if (fork() == 0){ //PID = 4124
            printf ("%d \n", getpid());
            exit(0); 
        }
        wait(NULL);
        if (fork() == 0){ //PID = 4125
            printf ("%d %d \n", getpid(), getppid());
            exit(0); 
        }
        return 0; 
    }
    ```
    Считаем, что printf работает атомарно и обращения ко всем системным вызовам успешно отрабатывают. Перечислить все возможные комбинации значений, которые могут быть выведены на стандартное устройство вывода в результате выполнения данной программы. 
    * 答案： 
    ```c
    4124
    4125 4123
    либо
    4124
    4125 1
    ```

5. System V文件系统
    * 我也搞不明白，甚至很难查到资料，抽到算你倒霉吧

    1. Пусть дана（给出） файловая система Unix System V и в ней утеряна（丢失了） информация суперблока. Предложить（建议） последовательность действий（操作，行动）, позволяющую（允许，用于） восстановить（还原，恢复） содержимое（内容） файлов данной файловой системы. Считаем（我们认为）, что до потери（丢失，损失） суперблока содержимое файловой системы было корректным（正确的）. Размер（大小） суперблока, размер и структура（结构） индексного（索引） дескриптора（描述符） известны（是已知的）.
    * 答案：Структура файловой системы версии System V:
        {Суперблок} + {Область индексных дескрипторов} + {Блоки файлов}.超级块 + 索引描述符区域 + 文件块
        Размер области индексных дескрипторов хранится в суперблоке. При потере информации суперблока, данное значение теряется（迷失，丢失）. 
        1. Для восстановления（恢复） содержимого файлов, необходимо（必须） определить границу между областью（区域） индексных дескрипторов и областью блоков файлов. Идем итеративно（迭代） от начала области индексных дескрипторов. Считываем（我们读取） очередной（下一个） ID.
        2. Проверяем（我们检查） содержимое（内容） поля（字段） «ссылки на данный ID каталогов（目录） файловой системы». Если это поле равно нулю (это означает（意味着）, что ID свободен（空闲的）) переходим（转换到） к следующему ID. 
        3. В противном случае（否则的话） последовательно（依次） просматриваем（查看） 13 элементов, описывающих（描述） адресацию（地址，寻址） блоков файла (до завершения（完成）): номера блоков с прямой（直接的） адресацией (10 шт.), номера блоков, организованных（有组织的） с косвенной（间接的） адресацией 1, 2 и 3-х уровневой（等级）. 
        4. В случае, если получен некорректный номер блока, завершаем（终止） алгоритм（算法） (область индексных дескрипторов закончилась). Альтернативой（另一种选择，替代方案） проверки（检查） поля（字段） со ссылками может являться проверка содержимого（内容） поля «тип файла»（文件类型）: если оно является некорректным, то это так же означает, что область индексных дескрипторов закончилась.

    2. Описать алгоритм определения（定义） размера файла в блоках по содержимому（内容） массива（数组） адресации（地址） блоков файла индексного（索引） дескриптора（描述符） (модельной（模型） Unix системы).Считаем（我们假设）, что массив состоит из элементов беззнакового целого.Размер блока – 2048 байт. 
    Считаем, что доступ（访问） к блокам файловой системы осуществляется посредством（他是被由...实现的） использования внешней（外部的） функции GetBlockFS, которая принимает（接受） в качестве（作为） параметра（参数，变量） номер блока файловой системы, который нужно считать, а возвращает（返回） указатель на считанный（读取的） блок.
    В решении（解决） предположить（方案）, что признаком окончания файла является 0 в массиве номеров блоков файла (отметим（注意）, что в общем（一般） случае это не гарантируется（保证）).
    * 答案：
        1. Вначале рассчитываем（计算）, сколько четырехбайтовых чисел (unsigned int) поместится（适合，在） в одном блоке:
        tmp = 2048 / sizeof(unsigned int) = 2048 / 4 = 512.
        2. Далее сначала рассматриваем первые 10 элементов массива адресации. Если встречаем（遇到） 0, то останавливаемся（停下来）. Рассматриваем 11-ый элемент. Если он равен нулю, то останавливаемся. 
        3. Иначе（否则） при помощи функции GetBlockFS получаем указатель на следующий блок, содержащий（内容包含） 512 номеров блоков.Также их проверяем на ноль. 
        4. Если не остановились, то переходим（转到） к 12-ому элементу, не забываем, что здесь уже косвенная（间接） адресация（寻址） второго уровня (данный элемент ссылается（指向的，连接到的） на массив из 512 ссылок, каждая из которых ссылается на массив из 512 блоков файла). 
        5. Далее, если не остановились, переходим к 13-ому элементу (где косвенная адресация уже третьего уровня).

    3. Как работает системный вызов（调用） open(filename, openmode, flags)?
    * 答案：
        1. Открывает файл с именем filename, режимом（模式） доступа（访问） openmode. Если openmode позволяет（允许） создание файла и файл не существует, то файл создается с правами（权限） flags;
        2. Устанавливается（安装，建立） связь（连接） с индексным（索引） дескриптором（描述符）, или создается новый ИД（ID）;
        3. Добавляется（添加） новая запись（条目） в ТОФ ОС（操作文件表）(указатель смещения（偏移量） в файле для чтения（读） / записи（写） и ссылка（链接） на ИД);
        4. Добавляется запись в ТОФ процесса (ссылка на запись в ТОФ ОС);
        5. Индекс（索引） данной（给出的） записи в ТОФ процесса возвращается（返回） как файловый дескриптор открытого файла.

6. IP地址的结构 
    * 和问题3一样，背下来
    * 其中<код_класса>类型码，<номер_сети>是网络号，<номер_компьютера_в_сети>是主机号

    1. Какова структура IP адреса класса С (описать все поля（字段） и их размеры（大小）)?
    * 答案：
    <код_класса><номер_сети><номер_компьютера_в_сети>
    <код_класса> – 110 (3 бита)
    <номер_компьютера_в_сети> – один байт
    <номер_сети> – оставшееся в IP адресе пространство (крайние левые три байта IP адреса без крайних левых трех битов)

    2. Какова структура IP адреса класса B (описать все поля и их размеры)?
    * 答案：
    <код_класса><номер_сети><номер_компьютера_в_сети>
    <код_класса> – 10 (2 бита)
    <номер_компьютера_в_сети> – 2 байта
    <номер_сети> – оставшееся в IP адресе пространство (крайние левые два байта IP адреса без крайних левых двух битов)

    3. Какова структура IP адреса класса A (описать все поля и их размеры)?
    * 答案：
    <код_класса><номер_сети><номер_компьютера_в_сети>
    <код_класса> – 0 (1 бит)
    <номер_компьютера_в_сети> – 3 байта
    <номер_сети> – оставшееся в IP адресе пространство, 7 битов

    4. Какова структура IP адреса класса D (описать все поля и их размеры)?
    * 答案：
    <код_класса><группа>
    <код_класса> – 1110 (4 бита)
    <группа> – оставшееся в IP адресе пространство (32 – 4 = 28 битов)

    5. Сколько байтов в структуре IP-адреса класса C отводится под номер компьютера?Где они расположены?
    * 答案：
    <код_класса><номер_сети><номер_компьютера_в_сети>
    Один байт, крайний справа


7. 进程通讯，问代码输出
    * 跟前面差不多，注意管道不管多少字节都可以传输，但是写入多少字节要看的write的第三个参数
    * write()的三个参数，第一个是写的目标地点，第二个是写的内容，第三个是写的字节数
    * puts(x+1);中相当于将x,也就是指向字符串的指针后移一个元素再打印，也就是打印字符串的第二个字符

    1. Что будет выведено на экран? Если возможны несколько вариантов – привести все. Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации. Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    屏幕上会显示什么？给出所有可能的情况。假设访问显示功能以原子方式工作，并且没有缓冲。所有系统调用都成功处理。头文件的链接被省略。
    ```c
    int main()
    {
        int fd[2];
        pipe(fd);
        char x[] = "01\n";
        if(fork()) {
            puts(x + 1);
            write(fd[1], x, 1);
            wait(NULL);
        } else {
            write(fd[1], &x[1], 1);
            read(fd[0], x, 1);
            read(fd[0], x+1, 1);
        }
        puts(x);
        return 0;
    }
    ```
    * 答案：
    ```c
    1 
    01 
    01 
    либо
    1
    10
    ```

    11. Что будет выведено на экран? Если возможны несколько вариантов – привести все. Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации. Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main() {
        int fd[2];
        pipe(fd);
        char x[] = "qw\n";
        if(fork()) {// pid=A
            write(fd[1], x, 1);
            wait(NULL);
        } else { //pid=B
            write(fd[1], &x[1], 1);
            read(fd[0], x, 1);
            read(fd[0], x+1, 1);
        }
        printf("%d ", getpid()); 
        puts(x);
        return 0;
    }
    ```
    * 答案：
    ```c
    B qw 
    A qw 
    либо
    B wq
    A qw
    ```

8. I/O，面向字符和面向块的I/O
    * 概念题

    1. Может ли одно и то же физическое устройство быть представлено в системе и как байт-ориентированное устройство и как блок-ориентированное? Ответ обосновать.
    同一个物理设备 是否可以在系统中 同时表示为 面向字符的设备 和 面向块的设备？ 给出并解释你的答案。
    * 答案：Может. Регистрируются 2 файла устройств, связанных с данным устройством. Один файл – байт-ориентированное устройство (связано（链接） с соответствующим（适当的） драйвером（驱动程序）), другой – блок-риентированное устройств

    2. Привести 2 примера байт-ориентированных устройств.给出面向字符的设备的2个示例。
    * 答案：Клавиатура, мышь （键盘，鼠标）（其实还有显示器，打印机等）
    
    3. Привести 3 примера блок-ориентированных устройств.给出面向块的设备的3个示例
    * 答案：Флэш-накопитель, жесткий диск, накопитель на магнитной ленте（闪存驱动器，硬盘驱动器，磁带驱动器）

    4. Верно ли, что любое физическое устройство представлено в системе и как байт-ориентированное устройство и как блок-ориентированное? Ответ обосновать.
    在系统中，任何物理设备都表示为 面向字符的设备 和 面向块的设备，这样说对吗？ 解释你的答案。
    * 答案：Нет. Не для всех устройств оба варианта имеют смысл. Например, для датчика（传感器） температуры блочное（块） представление（表示） не нужно.

9. 进程，wait()，问代码输出
    * wait(0)和wait(NULL)都是将父进程挂起，并等待子进程退出

    1. Что будет выведено（显示） на экран, если PID изначально запущенного（运行） процесса равен 1277? Если возможны несколько вариантов – привести все варианты. Предполагается（假设）, что все системные вызовы（调用） прорабатывают（处理） успешно（成功）. Подключение（连接） заголовочных файлов опущено（省略）.
    ```c
    int main()
    {
        int pid;
        if (fork() == 0) {
            printf ("PPID = %d \n", getppid());
        } else {
            exit(0);
        }
    }
    ```
    * 答案：PPID=1277 или PPID=1

    5. Что будет выведено на экран, если PID изначально запущенного процесса равен A, а PID запущенных процессов - B или C? Если возможны нескольковариантов – привести все варианты. Предполагается, что все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main() {
        if(fork()==0) // B
        if(fork()==0){ // C
            printf ("PPID1=%d\n",getppid());
        }else{
            printf ("PPID2=%d\n",getppid());
            wait(NULL); exit(0);
        }else // A
        exit(0); 
    }
    ```
    * 答案：
    ```c
    PPID1=B
    PPID2=A
    или
    PPID2=A
    PPID1=B
    или
    PPID1=B
    PPID2=1
    или
    PPID2=1
    PPID1=B
    ```


10. 系统调用和库调用
    * 也是概念题

    1. Может ли пользовательский（用户的） процесс в Unix System V выполняться（运行） в режиме（模式） операционной системы? Обосновать ответ. 
    * 答案：Да. При обращении（地址） к системным вызовам
        可以，在系统调用的时候

    2. Привести примеры библиотечных функций языка С, не содержащих в своей реализации（实现） системные вызовы.
    * 答案：Большинство функций работы со строками（字符串） (например, sscanf, strlen)

    3. Чем отличается（区别） системный вызов от библиотечной функции? Вычеркнуть（删除） из списка（列表） все системные вызовы:
    ```c
    read(fd, buffer, N);
    scanf(“%d”, &i);
    sscanf(buffer, “%d”, &i);
    k = ftok(“/etc/passwd”, ‘A’);
    id = msgget(k, IPC_CREAT | 0666);
    ```
    * 答案：
        При обращении к системным вызовам процесс переходит（切换） в привилегированный（特权） режим, в котором выполняются（执行） нужные функции ядра ОС. Библиотечные функции работают в пользовательском режиме, обращаясь, если надо к системным вызовам.
        Библиотечные функции: 
        ```c
        scanf(“%d”, &i);
        sscanf(buffer, “%d”, &i);
        k = ftok(“/etc/passwd”, ‘A’);
        ```

    4. Как работает системный вызов wait(int * status)?
    * 答案：
        * Процесс блокируется（阻塞） до завершения（返回） какого-либо потомка（后代，子进程）. Если потомков нет (или всех уже дождались（等到了）), то возвращается -1;
        * удаляет завершившийся（已完成的，已经终止的） процесс-потомок из таблицы процессов;
        * статус（状态） завершения потомка записывается（写入） в *status(если указатель（指针） ненулевой（非零）);
        * возвращает pid завершенного потомка.Также при wait процесс блокируется до прихода сигнала, который либо завершит（结束） текущий процесс, либо вызовет（调用） функцию-обработчик（程序处理函数）. Если ожидание（等待） было прервано（中断） сигналом, то возвращается -1.

    5. Чем отличается системный вызов от библиотечной функции? Какие библиотечные функции ниже НЕ обращаются（处理） к системным вызовам?
    ```c
    scanf(“%d”, &i);
    sscanf(buffer, “%d”, &i);
    k = ftok(“/etc/passwd”, ‘A’);
    d = sqrt(x);
    ```
    * 答案：
        При обращении к системным вызовам процесс переходит в привилегированный режим, в котором выполняются нужные функции ядра ОС. Библиотечные функции работают в пользовательском режиме, обращаясь, если надо к системным вызовам.Библиотечные функции, которые не обращаются к системным вызовам: 
        ```c
        sscanf(buffer, “%d”, &i);
        d = sqrt(x);
        ```

    6. В каких режимах будет работать процесс при выполнении（执行） функции printf()? Обосновать ответ.
    * 答案：Частично（部分） в пользовательском (подготовка（准备） данных для вывода（输出）), частично в привилегированном（特权） (собственно（实际上） вывод（输出） через системный вызов write())

    7. В каком режиме（模式） выполняется（运行） пользовательский процесс в Unix System V при обращеии к системным вызовам（访问系统调用）?
    * 答案：В режиме операционной системы


11. 套接字
    * 我还没算明白

    1. В системе клиент-сервер, реализованной с использованием сокетов, подключены и работают три клиентских процесса. Обосновать, какое минимальное количество сокетов может быть единовременно открыто у процесса-сервера в этом случае?
    * 答案：Один, т.к. сервер для каждого подключенного клиента может формировать отдельный процесс, после чего закрывать сокет, связанный с клиентом.

    4. В системе клиент-сервер, реализованной с использованием сокетов, работает один серверный процесс, в котором открыт 1 серверный и 3 клиентских сокета. Обосновать, какое минимальное количество клиентских процессов может единовременно работать в этом случае?
    * 答案：Ни одного клиентского процесса, т.к. сервер для каждого подключенного клиента может асинхронным образом обрабатывать соединения, не заводя для этого клиентский процесс.

    6. Каким образом можно добиться того, чтобы в системе клиент-сервер (реализованной с использованием сокетов) при работе с пятью клиентскими процессами у процесса-сервера был бы открыт только один сокет?
    * 答案：Формировать отдельный процесс для каждого подключенного клиента, затем закрывать сокет, связанный с клиентом.


12. 文件系统，文件块
    * 就是问，给定链接组成的文件系统，设文件块中的链接占用x字节，文件块的大小为y字节，需要最少多少次交换才能读懂m到n的部分文本
    * 文件块中的信息有y-x个字节，共有n/(y-x)个区块，这个答案需要向上取整。

    1. Дана файловая система, имеющая организацию в виде связанного списка. Пусть ссылка в файловом блоке занимает 8 байтов, а размер файлового блока равен 1024 байтам. Пусть некоторый файл из данной файловой системы содержит текстовую информацию (последовательность байтов, содержащих коды символов). За какое минимальное количество обменов можно прочесть часть текста с 2047 символа до 3072 (считаем, что нумерация символов в тексте начинается с 1). 
    * 答案：Четыре обмена

    2. Дана файловая система, имеющая организацию в виде связанного списка. Пусть ссылка в файловом блоке занимает 4 байта, а размер файлового блока равен 1024 байтам. Пусть некоторый файл из данной файловой системы содержит текстовую информацию (последовательность байтов, содержащих коды символов). За какое минимальное количество обменов можно прочесть часть текста с 2047 символа до 5172 (считаем, что нумерация символов в тексте начинается с 1).
    * 答案：Содержательная информация в файловом блоке занимает: 1024 – 4 = 1020 байтов.
        Нам надо прочитать до 5172 байта: 5172 / 1020 = 5.071 блоков.
        Таким образом, нам надо пройти 6 блоков (то есть округляем 5.071 в большую сторону), то есть выполнить 6 обменов.

13. 文件系统，文件块的恢复
    * 比较难的概念题，但还是只能背。

    1. При сверке целостности файловой системы i-й элемент таблицы занятых блоков равен 3. А i-й элемент таблицы свободных блоков равен 5. Описать последовательность действий, восстанавливающих системную информацию файловой системы.
    * 答案：
        Находим 3 индексных дескриптора, содержащих блок с номером i, делаем копию соответствующих файлов, удаляем 3 оригинальных файла, переименовываем копии файлов в имена исходных файлов, перевосстанавливаем таблицу занятых блоков, перевосстанавливаем таблицу свободных блоков.

    2. Дать краткое описание основных шагов алгоритма восстановления списка свободных индексных дескрипторов файловой системы System V.
    * 答案：
        Цикл по области индексных дескрипторов. 
        Индексный дескриптор считается свободным, если его поле «количество ссылок из каталогов файловой системы» равно 0.

    3. Пусть в файловой системе используется модель учёта свободных блоков на основе битовых массивов. Сколько блоков ФС займёт этот битовый массив для жёсткого диска объёмом в 8 Гбайт, если размер блока равен 2 Кбайт.
    * 答案：
        Диск = (8*1024*1024) / 2 = 2^22 блоков;
        2^22 бит = 2^8 * 2 Кбайт = 2^8 блоков
        也就是，先根据给出的磁盘大小和块大小计算出整个磁盘分多少块，然后按照每块占用一字节算出总共需要多少空间，最后算出这些空间是占用多少块。


14. 文件系统，归档
    * 好像不是很难的概念题。

    1. Перечислить основные шаги инкрементального архивирования файлов.
    * 答案：
        Создание цепочки архивов: 
        1. Создаем мастер-копию архива – копия всех архивируемых файлов. 
        2. По расписанию создаем копии «изменений» –копия, в которой сохранены файлы, созданные или измененные с момента предыдущего архивирования.

    2. В системе, в различных процессах единовременно N кратно открыт файл с именем Name – в существующих в системе процессах имеется N файловых дескрипторов, связанных с файлом Name. Из которых К файловых дескрипторов являются унаследованными. Какое количество записей, связанных с данным файлом, имеется в Таблице файлов операционной системы?
    * 答案：
        При fork() в системе появляются новые файловые дескрипторы (в Таблицах открытых файлов сыновьих процессов), но новые записи в Таблицу файлов операционной системы не заносятся.
    Таким образом, получаем ответ: N-k.

    3. Если файл не является символической ссылкой, то где именно хранится ссылка на индексный дескриптор этого файла?
    * 答案：В файле каталога.

    4.  Перечислите две ситуации, в которых системный вызов fork() может вернуть -1.
    * 答案：
        * Системе не хватает ресурсов для размещения нового процесса;
        * Превышен лимит максимального числа процессов для пользователя или всей системы.

    5. Где именно хранится имя файла в файловой системе?
    * 答案：В файле каталога.

    6. Перечислите три ситуации, в которых системный вызов waitpid(pid, NULL, flags) может вернуть -1.
    * 答案：
        * У процесса нет потомков, которых надо дожидаться (либо вообще не было, либо всех дождались);
        * Неверный pid;
        * Неверные флаги.

    7. Каково основное преимущество инкрементального архивирования файлов?
    * 答案：При изменении файлов добавляют только различия, не надо все заново архивировать.

    8. Перечислить достоинства и недостатки компрессии при архивировании.
    * 答案：
        Достоинства: выигрыш в объеме резервной копии.Недостатки: компрессия чувствительна к потереинформации. Потеря/добавление одного бита может повлечь за собой порчу всего архива.

15. 文件系统，“外部页表”包含多少个条目
    * 这个题相当于问，一台实现两级页表的x位计算机，页面大小为y字节，每个二级表的大小为n条记录，“外部页表”包含多少个条目？
    * 虚拟地址是一级页号，二级页号和页中偏移量的组合，共有x位，计算出偏移量为log2(y)位，第一级页码为log2(n)位
    * 那么第二级页码就是m = x-log2(y)-log2(n)位，最后算出外部页表包含 2^m 个条目。

    2. Пусть в 32-разрядном компьютере используется страничная память с двухуровневой таблицей страниц. Размер страницы 4096 байтов. Таблица страниц первого уровня (внешняя) содержит 8192 записи. Определить размер каждой таблицы второго уровня.
    * 答案：
        Виртуальный адрес – это комбинация номера страницы первого уровня, номера страницы второго уровня и смещения в странице, всего 32 бита.
        4096 = 2^12, следовательно под смещение в странице отводится 12 бит.
        8192 = 2^13, следовательно под номер страницы первого уровня отводится 13 бит.
        Под номер страницы второго уровня остается 32-12-13=7 бит.
        Следовательно, размер каждой таблицы второго уровня равен 2^7=128 записей.

    5.  Пусть дан 32-разрядный компьютер, в котором реализована двухуровневая таблица страниц. Размер страницы 4096 байтов. Каждая таблица второго уровня содержит 256 записей. Сколько записей содержит «внешняя таблица страниц»?
    * 答案：2 ^ (32 – log 4096 – log 256) = 2 ^ (32 – 12 – 8) = 2 ^ 12 = 4096

16. Dijkstra信号量
    * 概念题，还比较好理解

    1. Дать формальное описание семафора Дейкстры, который может использоваться для реализации взаимного исключения.
    * 答案：Дать определение семафора, у которого начальное и максимальное значение равно 1

    2. Дать формальное описание семафора Дейкстры, который может использоваться для реализации одновременного доступа к ресурсу не более 4-х процессов.
    * 答案：Дать определение семафора, у которого начальное и максимальное значение равно 4

    3. Привести схему взаимного исключения процессов с помощью двоичного семафора Дейкстры.
    * 答案：Семафор в начальном состоянии должен быть открыт (=1). Схема:
    P (закрыть семафор) – критическая секция – V (открыть семафор)

    4. Привести схему взаимного исключения процессов с помощью семафоров IPC.
    * 答案：Семафор (semid) в начальном состоянии должен быть открыт (=1). Схема:
    ```c
    struct sembuf P = {0, -1, 0};
    struct sembuf V = {0, 1, 0};
    semop(semid, &P, 1); //(закрыть семафор) 
    //– критическая секция – 
    semop(semid, &V, 1); //(открыть семафор)
    ```

    5. Можно ли реализовать семафор Дейкстры через обычную целую переменную и активное ожидание, например:
    ```c
    int sem =1;
    while (sem == 0); // ждем пока семафор поднимут
    sem=0; // входим в критическую секцию
    //работаем с разделяемым ресурсом
    sem=1; // выходим из критической секции
    ```
    * 答案：
    Нет, отсутствует атомарность: между проверкой и установкой семафора может произойти переключение на другой процесс

    6. Дать формальное описание семафора Дейкстры, который может использоваться для реализации единовременного доступа к ресурсу не более чем 2-х процессов.
    * 答案：
    Дать определение семафора, у которого начальное и максимальное значение равно 2

    7. Дать описание операций, которые могут выполняться над семафором Дейкстры.
    * 答案：
    Атомарная операция down(S): проверяет значение семафора S. Если оно больше нуля, то уменьшает его на 1, иначе процесс блокируется (связанная с процессом операция down считается незавершенной).
    Атомарная операция up(S): увеличивает значение семафора на 1. Если в системе присутствуют процессы, блокированные ранее операцией down на этом семафоре, один из них разблокируется и завершает выполнение операции down.

    8.  Дать формальное описание семафора Дейкстры, который может использоваться для реализации взаимного исключения. Какие средства межпроцессного взаимодействия (кроме собственно семафоров) могут быть использованы для реализации взаимного исключения и как?
    * 答案：
    Дать определение семафора, у которого начальное и максимальное значение равно 1.
    Каналы через блокировку на чтение из пустого канала.
    Очереди сообщений через блокировку на чтение сообщений нужного типа.
    Сигналы через блокировку на ожидании сигнала.

17. 文件系统中可以具有的块中最大文件大小是多少
    * 还没搞明白是怎么算的

    1. Дана файловая система, имеющая архитектуру,аналогичную fs5. Пусть размер ссылки на блок файловой системы – 4 байта; размер блока 32 байта. Какой предельный размер файла в блоках могут иметь файлы в такой файловой системе (указать число)?
    * 答案：10+8+8^2+8^3 = 594

    5. Дана файловая система, архитектура которой аналогична fs5. Пусть размер ссылки на блок файловой системы – 4 байта; размер блока 64 байта. Найдите предельный размер файла в такой файловой системе (указать константное выражение) в байтах.
    * 答案：64 * (10+16+16^2+16^3)

    6. Дана файловая система, имеющая архитектуру,аналогичную fs5. Пусть размер ссылки на блок файловой системы – 8 байтов; размер блока 2048 байтов. Какой предельный размер файла в блоках могут иметь файлы в такой файловой системе (указать константное выражение)?
    * 答案：10+256+256^2+256^3

18. 页表，虚拟RAM和物理内存的关系计算
    1. Пусть в некотором компьютере реализована страничная организация памяти, таблица страниц операционной системы имеет размер 4096 записей. Размер страницы 512 байтов. Определите разрядность виртуального адреса для данного случая.
    * 答案：21 разряд

    2. Пусть в некотором компьютере реализована страничная организация памяти с использование инвертированной таблицы страниц, состоящей из 300 записей. Размер виртуальной страницы ОЗУ 2048 байтов. Каков объем физической памяти этого компьютера?
    * 答案：300 х 2048 байтов

    5. Пусть в некотором компьютере реализована страничная организация памяти, таблица страниц операционной системы имеет размер 2048 записей. Размер страницы 4096 байтов. Определите разрядность виртуального адреса для данного случая.
    * 答案：log 2048 + log 4096 = 23 разряда

19. 中断
    1. Для каких целей в рассмотренной в курсе модели обработки прерываний введена блокировка прерываний?
    * 答案：
    Для того, чтобы в момент сохранения точки и контекста прерывания не пришло другое прерывание, и не произошла потеря информации о точке первого прерывания.

    2. Всегда ли в устройствах, работающих по протоколу TCP/IP, поддерживаются все 4 уровня взаимодействия (протокола)? Ответ обосновать.
    * 答案：
    Нет, не всегда (например, в шлюзах реализованы только первые два уровня, поскольку они просто передают информацию, и уровни более высокого уровня представления в них не нужны).

    3. Чем отличаются длинные и короткие прерывания? Дать пример длинного прерывания.
    * 答案：
    При коротком прерывании не происходит смена контекста выполняемого процесса, поэтому достаточно только малого упрятывания информации о выполняемой программе (флаги, регистры процессора). Длинное прерывание – от контроллера прямого доступа в память

    4. Чем отличаются длинные и короткие прерывания? Дать пример короткого прерывания.
    * 答案：
    При коротком прерывании не происходит смена контекста выполняемого процесса, поэтому достаточно только малого упрятывания информации о выполняемой программе (флаги, регистры процессора). Короткое прерывание – от клавиатуры.

    5. Для каких целей в рассмотренной в курсе модели обработки прерываний введена блокировка прерываний?В каком из средств межпроцессного взаимодействия используется (может быть использован) похожий механизм?
    * 答案：
    Для того, чтобы в момент сохранения точки и контекста прерывания не пришло другое прерывание, и не произошла потеря информации о точке первого прерывания.
    Такой же механизм может использоваться при обработке сигналов – пока обрабатывается один сигнал, доставка других сигналов может быть заблокирована.

20. 关于信号的代码输出
    6. Что будет выведено на экран? Если возможны несколько вариантов – привести все.Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main(){
        pid_t pid;
        int fd[2];
        int x = 3;
        pipe(fd);
        if( (pid = fork()) > 0 ) { 
            read(fd[0], &x, sizeof(int)); 
            kill(pid, SIGKILL); 
        } else { 
            printf("%d", x); x = 2; 
            write(fd[1], &x, sizeof(int)); x = 1;
        }
        printf("%d", x);
        return 0;
    }
    ```
    * 答案：32 либо 312 либо 321

    9. Что будет выведено на экран? Если возможны несколько вариантов – привести все.Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main() {
        pid_t pid;
        int fd[2];
        int x = 9;
        pipe(fd);
        if( (pid = fork()) > 0 ) { 
            printf("%d", x - 1);
            read(fd[0], &x, sizeof(int));
            kill(pid, SIGKILL);
            wait(NULL);
        } else { 
            x = 6;
            printf("%d", x);
            x = 3;
            write(fd[1], &x, sizeof(int));
            x = 7;
        }
        printf("%d", x);
        return 0;
    }
    ```
    Поясните свой ответ.
    * 答案：
    ```c
    863
    683

    8673
    6873

    6783
    ```


21. 程序输出，关于POSIX消息队列
    1. Что будет выведено на экран в результате работы фрагмента программы? Если возможны несколько вариантов – привести все.Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    msgId – идентификатор существующей пустой очереди сообщений.
    ```c
    struct{
        long type;
        char data[1];
    } msg;
    ……..
    msg.type = 1; msg.data[0] = 'a'; msgsnd(msgId, &msg, 1, 0);
    msg.type = 2; msg.data[0] = 'b'; msgsnd(msgId, &msg, 1, 0);
    msg.type = 2; msg.data[0] = 'c'; msgsnd(msgId, &msg, 1, 0);
    msg.type = 1; msg.data[0] = 'd'; msgsnd(msgId, &msg, 1, 0);
    msgrcv(msgId, &msg, 1, 2, 0); putchar(msg.data[0]); 
    msgrcv(msgId, &msg, 1, 0, 0); putchar(msg.data[0]);
    msgrcv(msgId, &msg, 1, 1, 0); putchar(msg.data[0]);
    ……
    ```
    * 答案：bad

    2. Что будет выведено на экран в результате работы фрагмента программы? Если возможны несколько вариантов – привести все.Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    msgId – идентификатор существующей пустой очереди сообщений.
    ```c
    struct {
        long type;
        char data[1];
        } msg;
    ……..
    msg.type = 1; msg.data[0] = '1'; msgsnd(msgId, &msg, 1, 0);
    msg.type = 2; msg.data[0] = '2'; msgsnd(msgId, &msg, 1, 0);
    msg.type = 2; msg.data[0] = 'a'; msgsnd(msgId, &msg, 1, 0);
    msg.type = 1; msg.data[0] = 'b'; msgsnd(msgId, &msg, 1, 0);
    msgrcv(msgId, &msg, 1, 2, 0); putchar(msg.data[0]); 
    msgrcv(msgId, &msg, 1, 0, 0); putchar(msg.data[0]);
    msgrcv(msgId, &msg, 1, 1, 0); putchar(msg.data[0]);
    ```
    * 答案：21b

    3.  Что будет выведено на экран в результате работы фрагмента программы? Если возможны несколько вариантов – привести все.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    msgId – идентификатор существующей пустой очереди сообщений.
    ```c
    struct {
        long type;
        char data[1];
    } msg;
    ……..
    msg.type = 1; msg.data[0] = 'x'; msgsnd(msgId, &msg, 1, 0);
    msg.type = 2; msg.data[0] = 'y'; msgsnd(msgId, &msg, 1, 0);
    msg.type = 2; msg.data[0] = 'z'; msgsnd(msgId, &msg, 1, 0);
    msg.type = 1; msg.data[0] = 't'; msgsnd(msgId, &msg, 1, 0);
    msgrcv(msgId, &msg, 1, 2, 0); write(1, msg.data[0], 1); 
    msgrcv(msgId, &msg, 1, 1, 0); write(1, msg.data[0], 1);
    msgrcv(msgId, &msg, 1, 0, 0); write(1, msg.data[0], 1);
    ……
    ```
    * 答案：yxz

22. 程序输出，关于fork和管道
    1. Что будет выведено на экран? Если возможны несколько вариантов– привести все. Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main(){
        char c;
        int fd[2], fd2[2];
        pipe(fd); pipe(fd2);
        if(fork() == 0) { 
            write(fd[1], &c, 1); 
            putchar('d'); 
            read(fd2[0], &c, 1); 
            putchar('b'); exit(0);
        }
        putchar('a'); read(fd[0], &c, 1); 
        putchar('c'); write(fd2[1], &c, 1); 
        wait(NULL);
        putchar('f'); return 0;
    }   
    ```
    * 答案：acdbf либо adcbf либо dacbf

    8. Что будет выведено на экран? Если возможны несколько вариантов – привести все. Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main() {
        char c = '1';
        int fd[2], fd2[2];
        pipe(fd); pipe(fd2);
        if(fork() == 0) { 
            write(fd[1], &c, 1);
            putchar('2');
            read(fd2[0], &c, 1);
            putchar('3');
            exit(0); 
        }
        putchar('4'); 
        read(fd[0], &c, 1);
        putchar('5');
        write(fd2[1], &c, 1);
        wait(NULL);
        putchar('6');
        return 0;
    }
    ```
    * 答案：
    ```c
    45236 
    либо
    24536
    либо
    42536
    ```

23. 关于信号量的代码，从列出的输出中选出不可能发生的选项
    1. Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.Вычеркните варианты вывода, невозможные при выполнении фрагментов программ тремя параллельными процессами (A,B,C):
    semId – идентификатор массива семафоров, состоящего из 1 семафора. Массив проинициализирован с помощью вызова: 
    ```c
    semctl(semId, 0, SETVAL, 2);
    ```
    Данный фрагмент выполняется двумя параллельными процессами (A и B):
    ```c
    struct sembuf op; op.sem_num = 0; op.sem_flg = 0; 
    op.sem_op = -1; semop(semId, &op, 1); putchar('1');
    putchar('2'); op.sem_op = 1; semop(semId, &op, 1);
    ```
    Данный фрагмент выполняется одним параллельным процессом С:
    ```c
    struct sembuf op; op.sem_num = 0; op.sem_flg = 0; 
    op.sem_op = -1; semop(semId, &op, 1); putchar('3');
    op.sem_op = 1; semop(semId, &op, 1);
    ```
    Варианты вывода:
    1) 12213
    2) 12123
    3) 11232
    4) 11322
    5) 11223
    6) 31212

    * 答案：
    Невозможные варианты вывода:
    1) 12213
    4) 11322


    3. Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.Вычеркните варианты вывода, невозможные при выполнении фрагментов программ тремя параллельными процессами (X,Y,Z):
    semId – идентификатор массива семафоров, состоящего из 1 семафора. Массив проинициализирован с помощью вызова: 
    ```c
    semctl(semId, 0, SETVAL, 2);
    ```
    Данный фрагмент выполняется двумя параллельными процессами (X и Y):
    ```c
    struct sembuf op; op.sem_num = 0; op.sem_flg = 0; 
    op.sem_op = -1; semop(semId, &op, 1); putchar('a');
    putchar('b'); op.sem_op = 1; semop(semId, &op, 1);
    ```
    Данный фрагмент выполняется одним параллельным процессом Z:
    ```c
    struct sembuf op; op.sem_num = 0; op.sem_flg = 0; 
    op.sem_op = -1; semop(semId, &op, 1); putchar('c');
    op.sem_op = 1; semop(semId, &op, 1);
    ```
    Варианты вывода:
    1) abbac
    2) ababc
    3) aabcb
    4) aacbb
    5) aabbc
    6) cabab

    * 答案：
    Невозможные варианты вывода:
    1) abbac
    4) aacbb

24. 另一类信号量的代码，写出可能出现的所有选项
    2. Что будет выведено на экран? Если возможны несколько вариантов – привести все.Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    semId – идентификатор массива семафоров, состоящего из 1 семафора 
    Массив проинициализирован с помощью вызова: 
    ```c
    semctl(semId, 0, SETVAL, 8);
    ```
    Фрагмент программы выполняется 3-мя параллельными процессами:
    ```c
    struct sembuf op; op.sem_num = 0; op.sem_flg = 0;
    op.sem_op = -3; semop(semId, &op, 1);
    write(1, "1", 1); write(1, "2", 1);
    op.sem_op = 2; semop(semId, &op, 1);
    ```
    * 答案：
    Варианты:
    121212
    121122
    112122
    112212

    6. Какие средства синхронизации можно выбрать и какие действия вставить в эту программу, чтобы сначала напечаталось AВ, потом CD или DC (оба варианта должны быть возможны)?
    ```c
    int main(void) {
        if (fork()) {
            write(1, “A”, 1);
            write(1, “C”, 1);
            wait(NULL);
        } else {
            write(1, “B”, 1);
            write(1, “D”, 1);
        }
    }
    ```
    * 答案：
    Можно использовать семафор:
    ```c
    int main(void) {
        semaphore s = 0;
        if (fork()) {
            write(1, “A”, 1);
            up(&s, 1);
            down(&s, 2);
            write(1, “C”, 1);
            wait(NULL);
        } else {
            down(&s, 1);
            write(1, “B”, 1);
            up(&s, 2);
            write(1, “D”, 1);
        }
    }
    ```

    9. Опишите словесно все варианты вывода на экранПредполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main()
    {
        int fd[2];
        char c[2];
        pipe(fd);
        write(fd[1], c, 2);
        fork();fork();fork();fork();
        read(fd[0], c, 1);
        write(1, "a", 1);
        write(1, "b", 1);
        write(fd[1], c, 1);
        wait(NULL);
        return 0;
    }
    ```
    * 答案：
    Будет выведена последовательность из a и b длиной в 32 символа, в которой содержится по 16 символов a и b. Любой префикс выводимого программой ответа будет начинаться с ‘a’, а разница между количеством ‘a’ и количеством ‘b’ в любом префиксе не меньше нуля и не больше двух.



25. 关于fork和管道的代码，列出所有可能输出
    2. Что будет выведено на экран? Если возможны несколько вариантов – привести все.Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main() {
        int fd[2];
        char c[2] ="34";
        pipe(fd);
        write(fd[1], c, 2);
        if(fork()) fork();
        read(fd[0], c, 1);
        write(1, "1", 1);
        write(1, "2", 1);
        write(fd[1], c, 1);
        wait(NULL);
        return 0;
    }
    ```
    * 答案：
    Варианты:
    121212
    121122
    112122
    112212

    3. Что будет выведено на экран? Если возможны несколько вариантов – привести все.Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main(){
        int fd[2];
        char c[2] ="34";
        pipe(fd);
        write(fd[1], c, 2);
        if (fork())
        fork();
        fork(); fork();
        read(fd[0], c, 2);
        write(1, "a", 1);
        write(1, "b", 1);
        write(fd[1], c, 2);
        wait(NULL);
        return 0;
    }
    ```
    * 答案：
    Будет выведена последовательность пар ab длиной 12 (всего 24 символа)


26. 关于多次fork和管道的代码，列出所有可能输出
    1. Что будет выведено на экран? Если возможны несколько вариантов – привести все.Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main()
    {
        int fd[2];
        pipe(fd);
        char x[] = "ba\n";
        if(fork()) { 
            puts(x + 1); write(fd[1], x, 1); 
            wait(NULL);
        } else { 
            write(fd[1], &x[1], 1); read(fd[0], x, 1); 
            read(fd[0], x+1, 1);
        }
        puts(x); return 0;
    }
    ```
    * 答案：
    a 
    ba 
    ba 
    либо
    a
    ab
    ba

    3. Что будет выведено на экран? Если возможны несколько вариантов – привести все.Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main() {
        int fd[2];
        pipe(fd);
        char x[] = "dc\n";
        if(fork()) { 
            puts(x + 1); 
            write(fd[1], x, 1); 
            wait(NULL);
        } else { 
            write(fd[1], &x[1], 1); 
            read(fd[0], x, 1); 
            read(fd[0], x+1, 1); 
        }
        puts(x); return 0;
    }
    ```
    * 答案：
    c
    dc
    либо
    c
    cd
    dc

27. 关于字符串，fork和管道的代码，描述进程会发生什么
    1. Описать, что произойдет с процессами и почему (все системные вызовы отрабатывают корректно – без отказов)
    ```c
    int main(int argc, char **argv) 
    {
        int fd[2];
        char c[2] = "ab";
        pipe(fd); 
        if(fork()) { /* процесс №1 */
            close (fd[0]);
            close (fd[1]);
        } else { /* процесс №2 */
            read(fd[0], c,1);
        }
    }
    ```
    * 答案：
    Процесс № 1: завершится. 
    Процесс № 2: зависнет, т.к. в системе не будет закрыт дескриптор записи в этот канал (дескриптор, который был унаследован процессом №2).

    3. Описать, что произойдет с процессами и почему (все системные вызовы отрабатывают корректно – без отказов)
    ```c
    int main(void) 
    {
        int fd[2];
        char c[] = "abc\n";
        if(fork() == 0) { /* процесс №1 */
            close (fd[0]);
            close (fd[1]);
        } else { /* процесс №2 */
            read(fd[0], &c, 2);
        }
    }
    ```
    * 答案：
    Поведение не определено, т.к. не инициализирован массив fd.

    5. Описать, что произойдет с процессами и почему (все системные вызовы отрабатывают корректно – без отказов)
    ```c
    int main(int argc, char **argv){
        int fd[2];
        char c[2] = "ab";
        pipe(fd); 
        if(fork()) {/*процесс №1*/
            close (fd[0]);
            close (fd[1]);
            wait(NULL);
        } else {/*процесс №2*/
            read(fd[0],c,1);
            close(fd[1]);
        }
    }
    ```
    * 答案：
    Процесс № 2: зависнет, т.к. в системе не будет закрыт дескриптор записи в этот канал (дескриптор, который был унаследован процессом №2).
    Процесс № 1: зависнет в ожидании завершения процесса № 2.


28. 关于文件，dup,lseek等的多进程代码,列出所有可能的输出并解释
    1. Содержимое файла “1.txt” – строка «abcde». Что будет выведено на экран? Если возможны несколько вариантов – привести все.Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main()
    {
        char c = 'a';
        int fd; 
        fd = open("1.txt", O_RDONLY);
        if(fork()){
            int fd2 = open("1.txt", O_RDONLY);
            int fd3 = dup(fd);
            lseek(fd, 2, SEEK_CUR);
            wait(NULL);
            read(fd2, &c, 1); write(1, &c, 1);
            read(fd3, &c, 1); write(1, &c, 1); 
        }else{ 
            read(fd, &c, 1); write(1, &c, 1); 
        }
        return 0;
    }
    ```
    * 答案：
        Ответ: aad либо cad

        Два варианта порождаются за счет «гонок» между lseek и read в «сыне». Сам вывод определяется тем, что при «наследовании» и дублировании файлового дескриптора файловый указатель является общим, а при open создается новый.


    3. Содержимое файла “1.txt” – строка «123456». Что будет выведено на экран? Если возможны несколько вариантов – привести все.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main(void)
    {
        char c = '0';
        int fd = open("1.txt", O_RDONLY);
        if(fork() == 0) {
            read(fd, &c, 1); write(1, &c, 1);
        } else {
            int fd2 = open("1.txt", O_RDONLY);
            int fd3 = dup(fd);
            lseek(fd, 2, SEEK_CUR);
            wait(NULL);
            read(fd2, &c, 1); write(1, &c, 1);
            read(fd3, &c, 1); write(1, &c, 1); 
        }
        return 0;
    }
    ```
    * 答案：
        Два варианта порождаются за счет «гонок» между lseek и read в «сыне». Сам вывод определяется тем, что при «наследовании» и дублировании файлового дескриптора файловый указатель является общим, а при open создается новый.
        Ответ:
        314 (lseek->read)
        114 (read -> lseek)


    8. Описать, что произойдет с процессами и почему (все системные вызовы отрабатывают атомарно и корректно – без отказов). Что будет выведено на экран? Если допустимы несколько вариантов вывода, приведите все.
    ```c
    int main(int argc, char **argv) 
    {
        int fd[2], buf = 10;
        pipe(fd);
        if(!fork()) {
            write (fd[1], &buf, sizeof(int)); buf++; 
            printf("%d\n", buf);
        } else { 
            while(read(fd[0], &buf, sizeof(int))) {
                buf--; printf("%d\n", buf);
            }
        }
        return 0;
    }
    ```
    * 答案：
        1. Сыновий процесс выполнит действия и завершится.
        2. Родительский процесс считает информацию из канала, выведет на экран «9» и зависнет (в нем не закрыт «пишуший» дескриптор канала и read будет ожидать его закрытия).
        
        На экран будет выведено:
        11
        9
        ИЛИ
        9
        11

29. 文件系统和机械硬盘寻道的问题
    1. В файловой системе используются битовые массивы для хранения информации о свободных и занятых блоках. Написать на Си функцию, принимающую в качестве параметров указатель на начало этого битового массива (последовательность байтов), номер блока файловой системы (нумерация с нуля), максимально возможный номер блока и возвращающую статус занятости этого блока: 0 –свободен, 1 занят, -1 – номер вне диапазона.
    * 答案：
    ```c
        // Предположим, CHAR_BIT == 8
        int is_free(unsigned char *BitBlocks, unsigned Num, 
        unsigned Max_Num) {
            if (Num > Max_Num) {
                return -1;
            } else {
                return (BitBlocks[Num >> 3] >> (7 - (Num & 7u))) & 1;
            }
        }
    ```

    2. Головка HDD находится на дорожке 100. Нужно выполнить следующие запросы к дорожкам:60, 5, 22, 83, 120, 71.Назвать последовательность запросов при использовании жадного алгоритма.
    * 答案：
        На каждом шаге выбираем ближайшую дорожку. 
        Получаем: 83, 71, 60, 22, 5, 120.

    3. Головка HDD находится на дорожке 90. Нужно выполнить следующие запросы к дорожкам:104, 20, 95, 56, 81, 3.Назвать последовательность запросов при использовании жадного алгоритма.
    * 答案：
        На каждом шаге выбираем ближайшую дорожку. 
        Получаем: 95, 104, 81, 56, 20, 3.

    4. Перечислите все ситуации, в которых системный вызов open(“/home/ira/dir/file”, O_RDONLY) может вернуть -1.
    * 答案：
        Замечание: не надо требовать перечислить ВСЕ ошибки, возникающие в ходе выполнения open, их в man – около 20. Достаточно назвать 3-4 различных ситуации, например:
        - файла /home/ira/dir/file нет
        - какая-то из директорий в пути /home/ira/dir/file отсутствует или недоступна
        - пользователь не имеет прав на чтение файла /home/ira/dir/file
        - в процессе нет доступных файловых дескрипторов для открытия
        - превышен системный лимит на число открытых файлов
        - файл /home/ira/dir/file заблокирован для чтения др.

    5. Перечислите все ситуации, в которых системный вызов execl(“/home/igor/dir/prog”) может вернуть -1.
    * 答案：
        Замечание: не надо требовать перечислить ВСЕ ошибки, возникающие в ходе выполнения exec, их в man – около 20. Достаточно назвать 3-4 различных ситуации, например:
        - файла /home/igor/dir/prog нет
        - какая-то из директорий в пути /home/igor/dir/ отсутствует или недоступна
        - пользователь не имеет прав на выполнение файла /home/igor/dir/prog
        - файл /home/igor/dir/prog не является исполняемым
        - файл /home/igor/dir/prog является исполняемым, но имеет неверный формат
        - в процессе нет доступных файловых дескрипторов для открытия
        - нет ресурсов ядра для загрузки нового тела процесса
        - файл /home/igor/dir/prog заблокирован для чтениядр.

    6. Пусть в некоторой ОС используется файловая система, использующая FAT. Для представления номера блока в системе используется беззнаковое целое. Написать функцию, которая по номеру начального блока файла (положительное целое число) определяет размер файла в блоках. Функция принимает в качестве параметров номер начального блока файла и указатель на область памяти, в которой находится FAT.
    * 答案：
        i-ая строка таблицы FAT хранит информацию о состоянии i-ого блока файловой системы, а, кроме того, в ней указывается номер следующего блока файла. Для получения списка блоков файловой системы, в которых хранится содержимое конкретного файла, необходимо найти номер начального блока, а затем, последовательно обращаясь к таблице размещения и извлекая из каждой записи номер следующего блока, дойти до ссылки на нулевую строку таблицы. Нулевая строка таблицы уже не относится к рассматриваемому файлу.
        ```c
        int calculateSize(unsigned int num, unsigned int *fat)
        {
            int counter = 0;
            while (num != 0) {
                num = fat[num];
                counter++;
            }
            return counter;
        }
        ```

30. 调用函数时会访问文件描述符多少次？解释每一次是做什么
    1. Сколько раз система обратится к содержимому индексных дескрипторов при вызове: open("/dir/dir/file", O_RDONLY) ?Прокомментировать, почему? Считаем, что ни один из элементов пути к файлу не является символической ссылкой.
    * 答案：4 раза. 
        1 - дескриптор для / - чтобы найти дескриптор для файла каталога dir
        2 - дескриптор для /dir - чтобы найти дескриптор для файла каталога /dir/dir
        4 - дескриптор для /dir/dir/ - чтобы найти дескриптор для файла /dir/dir/ file
        5 - дескриптор для /dir/dir/file – чтобы проверить права доступа для этого файла и последующего чтения в память.

    2. Сколько раз система обратится к содержимому индексных дескрипторов при вызове: open("/dir1/dir2/dir3/file", O_RDONLY)?Прокомментировать, почему? Считаем, что ни один из элементов пути к файлу не является символической ссылкой.
    * 答案：5 раз. 
        1 - дескриптор для / - чтобы найти дескриптор для файла каталога dir1
        2 - дескриптор для /dir1 - чтобы найти дескриптор для файла каталога /dir1/dir2
        3 - дескриптор для /dir1/dir2 - чтобы найти дескриптор для файла каталога /dir1/dir2/dir3
        4 - дескриптор для /dir1/dir2/dir3 - чтобы найти дескриптор для файла /dir1/dir2/dir3/file
        5 - дескриптор для /dir1/dir2/dir3/file – чтобы проверить права доступа для этого файла и последующего чтения в память.

    3. Сколько раз система обратится к содержимому индексных дескрипторов при вызове: open("/dir1/file", O_RDONLY) ?Прокомментировать, почему? Считаем, что ни один из элементов пути к файлу не является символической ссылкой.
    * 答案：3 раза. 
        1 - дескриптор для / - чтобы найти дескриптор для файла каталога dir1
        2 - дескриптор для /dir1 - чтобы найти дескриптор для файла /dir1/file
        3 - дескриптор для /dir1/file – чтобы проверить права доступа для этого файла и последующего чтения в память.

    4. Сколько индексных дескрипторов нужно прочитать, чтобы загрузить файл /usr/exm/file.dat ?Считаем, что ни один из элементов пути к файлу не является символической ссылкой.
    * 答案：4

    5. Сколько индексных дескрипторов нужно прочитать, чтобы загрузить файл /home/program/dz/files/task.c ?Считаем, что ни один из элементов пути к файлу не является символической ссылкой.
    * 答案：6

