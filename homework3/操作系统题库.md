1. 奇偶校验
    * 根据进制将数字转为多位二进制，如八进制就是三位二进制数字，而16进制就是4位二进制数字

    1. В оперативном запоминающем устройстве 16-разрядного компьютера используется контроль целостности данных по четности. Описать возможную структуру ячейки памяти и ее побитовое содержимое для случая хранения в машинном слове восьмеричного числа (17735)8.
    * 答案:(17735)8. Посчитаем число двоичных единиц в каждой восьмеричной цифре: 1 + 3 + 3 + 2 + 2 = 11, число нечетное. Тогда бит паритета равен 1. Структура ячейки памяти: 16 бит данных (0001111111011101) + 1 бит паритета (1), который вычисляется как сумма по модулю 2 (XOR) всех битов данных.

    4. В оперативном запоминающем устройстве 16-разрядного компьютера используется контроль целостности данных по четности. Описать возможную структуру ячейки памяти и ее побитовое содержимое для случая хранения в машинном слове четверичного числа (1033231)4.
    * 答案：(1033231)4. Посчитаем число двоичных единиц в каждой четверичной цифре: 1 + 0 + 2 + 2 + 1 +2 + 1 = 9, число нечетное. Тогда бит паритета равен 1. Структура ячейки памяти: 16 бит данных (0001001111101101) + 1 бит паритета (1), который вычисляется как сумма по модулю 2 (XOR) всех битов данных.

    6. В оперативном запоминающем устройстве 32-разрядного компьютера используется контроль целостности данных по нечетности. Описать возможную структуру ячейки памяти и ее побитовое содержимое для случая хранения в машинном слове 16-ичного числа (FF001077)16
    * 答案：(FF001077)16. Посчитаем число двоичных единиц в каждой ненулевой 16-ичной цифре: 4 + 4 + 1 + 3 + 3 = 15, число нечетное. Тогда бит паритета равен 1. Структура ячейки памяти: 32бита данных (11111111000000000001000001110111) + 1 бит паритета (1), который вычисляется как сумма по модулю 2 (XOR) всех битов данных.

2. RAM地址分层
    1. Пусть дано восьмеричное число (173357)8, являющееся адресом оперативной памяти, расслоенной по 16 банкам. Банку с каким номером принадлежит заданный адрес?
    * 答案：(173357)8. В схеме расслоения памяти последовательные адреса размещаются в последовательных банках памяти. При 16 банках памяти за номер банка будут отвечать младшие 4 бита адреса. Они равны 1111, то есть 15. Ответ: банк памяти 15. (нумерация банков памяти с 0)

    5. Пусть дано четверичное число (323112)4, являющееся адресом оперативной памяти, расслоенной по 8 банкам. Банку с каким номером принадлежит заданный адрес?
    * 答案：(323112)4. В схеме расслоения памяти последовательные адреса размещаются в последовательных банках памяти. При 8 банках памяти за номер банка будут отвечать младшие 3 бита адреса. Они равны 110, то есть 6. Ответ: банк памяти 6. (нумерация банков памяти с 0)

    6. Пусть дано 16-ичное число (FAD1D31A)16, являющееся адресом оперативной памяти, расслоенной по 16 банкам. Банку с каким номером принадлежит заданный адрес?
    * 答案：(FAD1D31A)16. В схеме расслоения памяти последовательные адреса размещаются в последовательных банках памяти. При 16 банках памяти за номер банка будет отвечать младшая 16-ичная цифра адреса. Она равна A_16, то есть 10. Ответ: банк памяти 10. (нумерация банков памяти с 0)

3. IP地址的结构
    1. Дан 32-разрядный IP адрес, имеющий в восьмеричном представлении вид: (23171171543)8. Определить: к какому классу относится данный IP адрес; номер сети (в восьмеричном представлении), к которой относится IP адрес
    * 答案：(23171171543)8. 
        10011001111001001111001101100011_2
        Старшие биты адреса: 10, это сеть класса B. 
        Номер сети – следующие 14 бит, номер хоста –оставшиеся 16 бит. Тогда номер сети: 
        01100111100100_2 = 14744_8.

    4. Дан 32-разрядный IP адрес, имеющий в 16-ичном представлении вид: (DF00BE20)16. Определить: к какому классу относится данный IP адрес; номер сети (в 16-ичном представлении), и десятичный номер хоста в сети, к которой относится IP адрес
    * 答案：(DF00BE20)16. 
        11011111000000001011111000100000_2
        Старшие биты адреса: 110, это сеть класса С. 
        Номер сети – следующие 21 бит, номер хоста –оставшиеся 8 бит. Тогда номер сети: 
        111110000000010111110_2 = 1F00BE_16, а номер хоста – 32_10 (20_16).

4. 进程调度，问代码输出
    1. Пусть процесс с PID A породил два сыновьих процесса с PID-ами B и C:
    ```c
    int main(int argc, char **argv) //PID = A
    {
        if (fork() == 0){ //PID = B
            printf ("%d %d\n", getppid(), getpid());
            exit(0);
        }
        if (fork() == 0){ //PID = C
            printf ("%d\n", getpid());
            exit(0); 
        }
        return 0; 
    }

    ```
    Считаем, что printf работает атомарно и обращения ко всем системным вызовам успешно отрабатывают. Перечислить все возможные комбинации значений, которые могут быть выведены на стандартное устройство вывода в результате выполнения данной программы. 
    * 答案：
    ```c
    A B
    C
    либо
    1 B
    C
    либо 
    C
    A B
    либо 
    C
    1 B
    ```

    4. Пусть процесс с PID 4123 породил два сыновних процесса с PID-ами 4124 и 4125:
    ```
    int main(int argc, char **argv) //PID = 4123 
    {
        if (fork() == 0){ //PID = 4124
            printf ("%d \n", getpid());
            exit(0); 
        }
        wait(NULL);
        if (fork() == 0){ //PID = 4125
            printf ("%d %d \n", getpid(), getppid());
            exit(0); 
        }
        return 0; 
    }
    ```
    Считаем, что printf работает атомарно и обращения ко всем системным вызовам успешно отрабатывают. Перечислить все возможные комбинации значений, которые могут быть выведены на стандартное устройство вывода в результате выполнения данной программы. 
    * 答案： 
    ```c
    4124
    4125 4123
    либо
    4124
    4125 1
    ```

5. System V文件系统
    1. Пусть дана файловая система Unix System V и в ней утеряна информация суперблока. Предложить последовательность действий, позволяющую восстановить содержимое файлов данной файловой системы. Считаем, что до потери суперблока содержимое файловой системы было корректным. Размер суперблока, размер и структура индексного дескриптора известны.
    * 答案：Структура файловой системы версии System V:
        {Суперблок} + {Область индексных дескрипторов} + {Блоки файлов}.
        Размер области индексных дескрипторов хранится в суперблоке. При потере информации суперблока, данное значение теряется. Для восстановления содержимого файлов, необходимо определить границу между областью индексных дескрипторов и областью блоков файлов. Идем итеративно от начала области индексных дескрипторов. Считываем очередной ID. Проверяем содержимое поля «ссылки на данный ID каталогов файловой системы». Если это поле равно нулю (это означает, что ID свободен) переходим к следующему ID. В противном случае последовательно просматриваем 13 элементов, описывающих адресацию блоков файла (до завершения): номера блоков с прямой адресацией (10 шт.), номера блоков, организованных с косвенной адресацией 1, 2 и 3-х уровневой. В случае, если получен некорректный номер блока, завершаем алгоритм (область индексных дескрипторов закончилась). Альтернативой проверки поля со ссылками может являться проверка содержимого поля «тип файла»: если оно является некорректным, то это так же означает, что область индексных дескрипторов закончилась.

    2. Описать алгоритм определения размера файла в блоках по содержимому массива адресации блоков файла индексного дескриптора (модельной Unix системы).Считаем, что массив состоит из элементов беззнакового целого. Размер блока – 2048 байт. Считаем, что доступ к блокам файловой системы осуществляется посредством использования внешней функции GetBlockFS, которая принимает в качестве параметра номер блока файловой системы, который нужно считать, а возвращает указатель на считанный блок.В решении предположить, что признаком окончания файла является 0 в массиве номеров блоков файла (отметим, что в общем случае это не гарантируется).
    * 答案：Вначале рассчитываем, сколько четырехбайтовых чисел (unsigned int) поместится в одном блоке:
        tmp = 2048 / sizeof(unsigned int) = 2048 / 4 = 512.
        Далее сначала рассматриваем первые 10 элементов массива адресации. Если встречаем 0, то останавливаемся. Рассматриваем 11-ый элемент. Если он равен нулю, то останавливаемся. Иначе при помощи функции GetBlockFS получаем указатель на следующий блок, содержащий 512 номеров блоков. Также их проверяем на ноль. Если не остановились, то переходим к 12-ому элементу, не забываем, что здесь уже косвенная адресация второго уровня (данный элемент ссылается на массив из 512 ссылок, каждая из которых ссылается на массив из 512 блоков файла). Далее, если не остановились, переходим к 13-ому элементу (где косвенная адресация уже третьего уровня).

    3. Как работает системный вызов open(filename, openmode, flags)?
    * 答案：
        1. Открывает файл с именем filename, режимом доступа openmode. Если openmode позволяет создание файла и файл не существует, то файл создается с правами flags;
        2. Устанавливается связь с индексным дескриптором, или создается новый ИД;
        3. Добавляется новая запись в ТОФ ОС (указатель смещения в файле для чтения / записи и ссылка на ИД);
        4. Добавляется запись в ТОФ процесса (ссылка на запись в ТОФ ОС);
        5. Индекс данной записи в ТОФ процесса возвращается как файловый дескриптор открытого файла.

6. IP地址的结构 
    1. Какова структура IP адреса класса С (описать все поля и их размеры)?
    * 答案：
    <код_класса><номер_сети><номер_компьютера_в_сети>
    <код_класса> – 110 (3 бита)
    <номер_компьютера_в_сети> – один байт
    <номер_сети> – оставшееся в IP адресе пространство (крайние левые три байта IP адреса без крайних левых трех битов)

    2. Какова структура IP адреса класса B (описать все поля и их размеры)?
    * 答案：
    <код_класса><номер_сети><номер_компьютера_в_сети>
    <код_класса> – 10 (2 бита)
    <номер_компьютера_в_сети> – 2 байта
    <номер_сети> – оставшееся в IP адресе пространство (крайние левые два байта IP адреса без крайних левых двух битов)

    3. Какова структура IP адреса класса A (описать все поля и их размеры)?
    * 答案：
    <код_класса><номер_сети><номер_компьютера_в_сети>
    <код_класса> – 0 (1 бит)
    <номер_компьютера_в_сети> – 3 байта
    <номер_сети> – оставшееся в IP адресе пространство, 7 битов

    4. Какова структура IP адреса класса D (описать все поля и их размеры)?
    * 答案：
    <код_класса><группа>
    <код_класса> – 1110 (4 бита)
    <группа> – оставшееся в IP адресе пространство (32 – 4 = 28 битов)

    5. Сколько байтов в структуре IP-адреса класса C отводится под номер компьютера?Где они расположены?
    * 答案：
    <код_класса><номер_сети><номер_компьютера_в_сети>
    Один байт, крайний справа


7. 进程通讯，问代码输出
    1. Что будет выведено на экран? Если возможны несколько вариантов – привести все. Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации. Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main()
    {
        int fd[2];
        pipe(fd);
        char x[] = "01\n";
        if(fork()) {
            puts(x + 1);
            write(fd[1], x, 1);
            wait(NULL);
        } else {
            write(fd[1], &x[1], 1);
            read(fd[0], x, 1);
            read(fd[0], x+1, 1);
        }
        puts(x);
        return 0;
    }
    ```
    * 答案：
    ```c
    1 
    01 
    01 
    либо
    1
    10
    ```

    11. Что будет выведено на экран? Если возможны несколько вариантов – привести все. Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации. Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main() {
        int fd[2];
        pipe(fd);
        char x[] = "qw\n";
        if(fork()) {// pid=A
            write(fd[1], x, 1);
            wait(NULL);
        } else { //pid=B
            write(fd[1], &x[1], 1);
            read(fd[0], x, 1);
            read(fd[0], x+1, 1);
        }
        printf("%d ", getpid()); 
        puts(x);
        return 0;
    }
    ```
    * 答案：
    ```c
    B qw 
    A qw 
    либо
    B wq
    A qw
    ```

8. I/O，面向字符和面向块的I/O
    1. Может ли одно и то же физическое устройство быть представлено в системе и как байт-ориентированное устройство и как блок-ориентированное? Ответ обосновать.
    * 答案：Может. Регистрируются 2 файла устройств, связанных с данным устройством. Один файл – байт-ориентированное устройство (связано с соответствующим драйвером), другой – блок-риентированное устройств

    2. Привести 2 примера байт-ориентированных устройств.
    * 答案：Клавиатура, мышь
    
    3. Привести 3 примера блок-ориентированных устройств.
    * 答案：Флэш-накопитель, жесткий диск, накопитель на магнитной ленте

    4. Верно ли, что любое физическое устройство представлено в системе и как байт-ориентированное устройство и как блок-ориентированное? Ответ обосновать.
    * 答案：Нет. Не для всех устройств оба варианта имеют смысл. Например, для датчика температуры блочное представление не нужно.

9. 进程，wait()，问代码输出
    1. Что будет выведено на экран, если PID изначально запущенного процесса равен 1277? Если возможны несколько вариантов – привести все варианты. Предполагается, что все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main()
    {
        int pid;
        if (fork() == 0) {
            printf ("PPID = %d \n", getppid());
        } else {
            exit(0);
        }
    }
    ```
    * 答案：PPID=1277 или PPID=1

    5. Что будет выведено на экран, если PID изначально запущенного процесса равен A, а PID запущенных процессов - B или C? Если возможны нескольковариантов – привести все варианты. Предполагается, что все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main() {
        if(fork()==0) // B
        if(fork()==0){ // C
            printf ("PPID1=%d\n",getppid());
        }else{
            printf ("PPID2=%d\n",getppid());
            wait(NULL); exit(0);
        }else // A
        exit(0); 
    }
    ```
    * 答案：
    ```c
    PPID1=B
    PPID2=A
    или
    PPID2=A
    PPID1=B
    или
    PPID1=B
    PPID2=1
    или
    PPID2=1
    PPID1=B
    ```


10. 系统调用和库调用
    1. Может ли пользовательский процесс в Unix System V выполняться в режиме операционной системы? Обосновать ответ. 
    * 答案：Да. При обращении к системным вызовам

    2. Привести примеры библиотечных функций языка С, не содержащих в своей реализации системные вызовы.
    * 答案：Большинство функций работы со строками (например, sscanf, strlen)

    3. Чем отличается системный вызов от библиотечной функции? Вычеркнуть из списка все системные вызовы:
    ```c
    read(fd, buffer, N);
    scanf(“%d”, &i);
    sscanf(buffer, “%d”, &i);
    k = ftok(“/etc/passwd”, ‘A’);
    id = msgget(k, IPC_CREAT | 0666);
    ```
    * 答案：
        При обращении к системным вызовам процесс переходит в привилегированный режим, в котором выполняются нужные функции ядра ОС. Библиотечные функции работают в пользовательском режиме, обращаясь, если надо к системным вызовам.Библиотечные функции: 
        ```c
        scanf(“%d”, &i);
        sscanf(buffer, “%d”, &i);
        k = ftok(“/etc/passwd”, ‘A’);
        ```

    4. Как работает системный вызов wait(int * status)?
    * 答案：
        * Процесс блокируется до завершения какого-либо потомка. Если потомков нет (или всех уже дождались), то возвращается -1;
        * удаляет завершившийся процесс-потомок из таблицы процессов;
        * статус завершения потомка записывается в *status(если указатель ненулевой);
        * возвращает pid завершенного потомка.Также при wait процесс блокируется до прихода сигнала, который либо завершит текущий процесс, либо вызовет функцию-обработчик. Если ожидание было прервано сигналом, то возвращается -1.

    5. Чем отличается системный вызов от библиотечной функции? Какие библиотечные функции ниже НЕ обращаются к системным вызовам?
    ```c
    scanf(“%d”, &i);
    sscanf(buffer, “%d”, &i);
    k = ftok(“/etc/passwd”, ‘A’);
    d = sqrt(x);
    ```
    * 答案：
        При обращении к системным вызовам процесс переходит в привилегированный режим, в котором выполняются нужные функции ядра ОС. Библиотечные функции работают в пользовательском режиме, обращаясь, если надо к системным вызовам.Библиотечные функции, которые не обращаются к системным вызовам: 
        ```c
        sscanf(buffer, “%d”, &i);
        d = sqrt(x);
        ```

    6. В каких режимах будет работать процесс при выполнении функции printf()? Обосновать ответ.
    * 答案：Частично в пользовательском (подготовка данных для вывода), частично в привилегированном (собственно вывод через системный вызов write())

    7. В каком режиме выполняется пользовательский процесс в Unix System V при обращении к системным вызовам?
    * 答案：В режиме операционной системы


11. 套接字
    1. В системе клиент-сервер, реализованной с использованием сокетов, подключены и работают три клиентских процесса. Обосновать, какое минимальное количество сокетов может быть единовременно открыто у процесса-сервера в этом случае?
    * 答案：Один, т.к. сервер для каждого подключенного клиента может формировать отдельный процесс, после чего закрывать сокет, связанный с клиентом.

    4. В системе клиент-сервер, реализованной с использованием сокетов, работает один серверный процесс, в котором открыт 1 серверный и 3 клиентских сокета. Обосновать, какое минимальное количество клиентских процессов может единовременно работать в этом случае?
    * 答案：Ни одного клиентского процесса, т.к. сервер для каждого подключенного клиента может асинхронным образом обрабатывать соединения, не заводя для этого клиентский процесс.

    6. Каким образом можно добиться того, чтобы в системе клиент-сервер (реализованной с использованием сокетов) при работе с пятью клиентскими процессами у процесса-сервера был бы открыт только один сокет?
    * 答案：Формировать отдельный процесс для каждого подключенного клиента, затем закрывать сокет, связанный с клиентом.


12. 文件系统，文件块
    1. Дана файловая система, имеющая организацию в виде связанного списка. Пусть ссылка в файловом блоке занимает 8 байтов, а размер файлового блока равен 1024 байтам. Пусть некоторый файл из данной файловой системы содержит текстовую информацию (последовательность байтов, содержащих коды символов). За какое минимальное количество обменов можно прочесть часть текста с 2047 символа до 3072 (считаем, что нумерация символов в тексте начинается с 1). 
    * 答案：Четыре обмена

    2. Дана файловая система, имеющая организацию в виде связанного списка. Пусть ссылка в файловом блоке занимает 4 байта, а размер файлового блока равен 1024 байтам. Пусть некоторый файл из данной файловой системы содержит текстовую информацию (последовательность байтов, содержащих коды символов). За какое минимальное количество обменов можно прочесть часть текста с 2047 символа до 5172 (считаем, что нумерация символов в тексте начинается с 1).
    * 答案：Содержательная информация в файловом блоке занимает: 1024 – 4 = 1020 байтов.
        Нам надо прочитать до 5172 байта: 5172 / 1020 = 5.071 блоков.
        Таким образом, нам надо пройти 6 блоков (то есть округляем 5.071 в большую сторону), то есть выполнить 6 обменов.

13. 文件系统，文件块的恢复
    1. При сверке целостности файловой системы i-й элемент таблицы занятых блоков равен 3. А i-й элемент таблицы свободных блоков равен 5. Описать последовательность действий, восстанавливающих системную информацию файловой системы.
    * 答案：
        Находим 3 индексных дескриптора, содержащих блок с номером i, делаем копию соответствующих файлов, удаляем 3 оригинальных файла, переименовываем копии файлов в имена исходных файлов, перевосстанавливаем таблицу занятых блоков, перевосстанавливаем таблицу свободных блоков.

    2. Дать краткое описание основных шагов алгоритма восстановления списка свободных индексных дескрипторов файловой системы System V.
    * 答案：
        Цикл по области индексных дескрипторов. 
        Индексный дескриптор считается свободным, если его поле «количество ссылок из каталогов файловой системы» равно 0.

    3. Пусть в файловой системе используется модель учёта свободных блоков на основе битовых массивов. Сколько блоков ФС займёт этот битовый массив для жёсткого диска объёмом в 8 Гбайт, если размер блока равен 2 Кбайт.
    * 答案：
        Диск = (8*1024*1024) / 2 = 2^22 блоков;
        2^22 бит = 2^8 * 2 Кбайт = 2^8 блоков


14. 文件系统，归档
    1. Перечислить основные шаги инкрементального архивирования файлов.
    * 答案：
        Создание цепочки архивов: 
        1. Создаем мастер-копию архива – копия всех архивируемых файлов. 
        2. По расписанию создаем копии «изменений» –копия, в которой сохранены файлы, созданные или измененные с момента предыдущего архивирования.

    2. В системе, в различных процессах единовременно N кратно открыт файл с именем Name – в существующих в системе процессах имеется N файловых дескрипторов, связанных с файлом Name. Из которых К файловых дескрипторов являются унаследованными. Какое количество записей, связанных с данным файлом, имеется в Таблице файлов операционной системы?
    * 答案：
        При fork() в системе появляются новые файловые дескрипторы (в Таблицах открытых файлов сыновьих процессов), но новые записи в Таблицу файлов операционной системы не заносятся.
    Таким образом, получаем ответ: N-k.

    3. Если файл не является символической ссылкой, то где именно хранится ссылка на индексный дескриптор этого файла?
    * 答案：В файле каталога.

    4.  Перечислите две ситуации, в которых системный вызов fork() может вернуть -1.
    * 答案：
        * Системе не хватает ресурсов для размещения нового процесса;
        * Превышен лимит максимального числа процессов для пользователя или всей системы.

    5. Где именно хранится имя файла в файловой системе?
    * 答案：В файле каталога.

    6. Перечислите три ситуации, в которых системный вызов waitpid(pid, NULL, flags) может вернуть -1.
    * 答案：
        * У процесса нет потомков, которых надо дожидаться (либо вообще не было, либо всех дождались);
        * Неверный pid;
        * Неверные флаги.

    7. Каково основное преимущество инкрементального архивирования файлов?
    * 答案：При изменении файлов добавляют только различия, не надо все заново архивировать.

    8. Перечислить достоинства и недостатки компрессии при архивировании.
    * 答案：
        Достоинства: выигрыш в объеме резервной копии.Недостатки: компрессия чувствительна к потереинформации. Потеря/добавление одного бита может повлечь за собой порчу всего архива.

15. 文件系统，“外部页表”包含多少个条目
    2. Пусть в 32-разрядном компьютере используется страничная память с двухуровневой таблицей страниц. Размер страницы 4096 байтов. Таблица страниц первого уровня (внешняя) содержит 8192 записи. Определить размер каждой таблицы второго уровня.
    * 答案：
        Виртуальный адрес – это комбинация номера страницы первого уровня, номера страницы второго уровня и смещения в странице, всего 32 бита.
        4096 = 2^12, следовательно под смещение в странице отводится 12 бит.
        8192 = 2^13, следовательно под номер страницы первого уровня отводится 13 бит.
        Под номер страницы второго уровня остается 32-12-13=7 бит.
        Следовательно, размер каждой таблицы второго уровня равен 2^7=128 записей.

    5.  Пусть дан 32-разрядный компьютер, в котором реализована двухуровневая таблица страниц. Размер страницы 4096 байтов. Каждая таблица второго уровня содержит 256 записей. Сколько записей содержит «внешняя таблица страниц»?
    * 答案：2 ^ (32 – log 4096 – log 256) = 2 ^ (32 – 12 – 8) = 2 ^ 12 = 4096

16. Dijkstra信号量
    1. Дать формальное описание семафора Дейкстры, который может использоваться для реализации взаимного исключения.
    * 答案：Дать определение семафора, у которого начальное и максимальное значение равно 1

    2. Дать формальное описание семафора Дейкстры, который может использоваться для реализации одновременного доступа к ресурсу не более 4-х процессов.
    * 答案：Дать определение семафора, у которого начальное и максимальное значение равно 4

    3. Привести схему взаимного исключения процессов с помощью двоичного семафора Дейкстры.
    * 答案：Семафор в начальном состоянии должен быть открыт (=1). Схема:
    P (закрыть семафор) – критическая секция – V (открыть семафор)

    4. Привести схему взаимного исключения процессов с помощью семафоров IPC.
    * 答案：Семафор (semid) в начальном состоянии должен быть открыт (=1). Схема:
    ```c
    struct sembuf P = {0, -1, 0};
    struct sembuf V = {0, 1, 0};
    semop(semid, &P, 1); //(закрыть семафор) 
    //– критическая секция – 
    semop(semid, &V, 1); //(открыть семафор)
    ```

    5. Можно ли реализовать семафор Дейкстры через обычную целую переменную и активное ожидание, например:
    ```c
    int sem =1;
    while (sem == 0); // ждем пока семафор поднимут
    sem=0; // входим в критическую секцию
    //работаем с разделяемым ресурсом
    sem=1; // выходим из критической секции
    ```
    * 答案：
    Нет, отсутствует атомарность: между проверкой и установкой семафора может произойти переключение на другой процесс

    6. Дать формальное описание семафора Дейкстры, который может использоваться для реализации единовременного доступа к ресурсу не более чем 2-х процессов.
    * 答案：
    Дать определение семафора, у которого начальное и максимальное значение равно 2

    7. Дать описание операций, которые могут выполняться над семафором Дейкстры.
    * 答案：
    Атомарная операция down(S): проверяет значение семафора S. Если оно больше нуля, то уменьшает его на 1, иначе процесс блокируется (связанная с процессом операция down считается незавершенной).
    Атомарная операция up(S): увеличивает значение семафора на 1. Если в системе присутствуют процессы, блокированные ранее операцией down на этом семафоре, один из них разблокируется и завершает выполнение операции down.

    8.  Дать формальное описание семафора Дейкстры, который может использоваться для реализации взаимного исключения. Какие средства межпроцессного взаимодействия (кроме собственно семафоров) могут быть использованы для реализации взаимного исключения и как?
    * 答案：
    Дать определение семафора, у которого начальное и максимальное значение равно 1.
    Каналы через блокировку на чтение из пустого канала.
    Очереди сообщений через блокировку на чтение сообщений нужного типа.
    Сигналы через блокировку на ожидании сигнала.

17. 文件系统中可以具有的块中最大文件大小是多少
    1. Дана файловая система, имеющая архитектуру,аналогичную fs5. Пусть размер ссылки на блок файловой системы – 4 байта; размер блока 32 байта. Какой предельный размер файла в блоках могут иметь файлы в такой файловой системе (указать число)?
    * 答案：10+8+8^2+8^3 = 594

    5. Дана файловая система, архитектура которой аналогична fs5. Пусть размер ссылки на блок файловой системы – 4 байта; размер блока 64 байта. Найдите предельный размер файла в такой файловой системе (указать константное выражение) в байтах.
    * 答案：64 * (10+16+16^2+16^3)

    6. Дана файловая система, имеющая архитектуру,аналогичную fs5. Пусть размер ссылки на блок файловой системы – 8 байтов; размер блока 2048 байтов. Какой предельный размер файла в блоках могут иметь файлы в такой файловой системе (указать константное выражение)?
    * 答案：10+256+256^2+256^3

18. 页表，虚拟RAM和物理内存的关系计算
    1. Пусть в некотором компьютере реализована страничная организация памяти, таблица страниц операционной системы имеет размер 4096 записей. Размер страницы 512 байтов. Определите разрядность виртуального адреса для данного случая.
    * 答案：21 разряд

    2. Пусть в некотором компьютере реализована страничная организация памяти с использование инвертированной таблицы страниц, состоящей из 300 записей. Размер виртуальной страницы ОЗУ 2048 байтов. Каков объем физической памяти этого компьютера?
    * 答案：300 х 2048 байтов

    5. Пусть в некотором компьютере реализована страничная организация памяти, таблица страниц операционной системы имеет размер 2048 записей. Размер страницы 4096 байтов. Определите разрядность виртуального адреса для данного случая.
    * 答案：log 2048 + log 4096 = 23 разряда

19. 中断
    1. Для каких целей в рассмотренной в курсе модели обработки прерываний введена блокировка прерываний?
    * 答案：
    Для того, чтобы в момент сохранения точки и контекста прерывания не пришло другое прерывание, и не произошла потеря информации о точке первого прерывания.

    2. Всегда ли в устройствах, работающих по протоколу TCP/IP, поддерживаются все 4 уровня взаимодействия (протокола)? Ответ обосновать.
    * 答案：
    Нет, не всегда (например, в шлюзах реализованы только первые два уровня, поскольку они просто передают информацию, и уровни более высокого уровня представления в них не нужны).

    3. Чем отличаются длинные и короткие прерывания? Дать пример длинного прерывания.
    * 答案：
    При коротком прерывании не происходит смена контекста выполняемого процесса, поэтому достаточно только малого упрятывания информации о выполняемой программе (флаги, регистры процессора). Длинное прерывание – от контроллера прямого доступа в память

    4. Чем отличаются длинные и короткие прерывания? Дать пример короткого прерывания.
    * 答案：
    При коротком прерывании не происходит смена контекста выполняемого процесса, поэтому достаточно только малого упрятывания информации о выполняемой программе (флаги, регистры процессора). Короткое прерывание – от клавиатуры.

    5. Для каких целей в рассмотренной в курсе модели обработки прерываний введена блокировка прерываний?В каком из средств межпроцессного взаимодействия используется (может быть использован) похожий механизм?
    * 答案：
    Для того, чтобы в момент сохранения точки и контекста прерывания не пришло другое прерывание, и не произошла потеря информации о точке первого прерывания.
    Такой же механизм может использоваться при обработке сигналов – пока обрабатывается один сигнал, доставка других сигналов может быть заблокирована.

20. 关于信号的代码输出
    6. Что будет выведено на экран? Если возможны несколько вариантов – привести все.Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main(){
        pid_t pid;
        int fd[2];
        int x = 3;
        pipe(fd);
        if( (pid = fork()) > 0 ) { 
            read(fd[0], &x, sizeof(int)); 
            kill(pid, SIGKILL); 
        } else { 
            printf("%d", x); x = 2; 
            write(fd[1], &x, sizeof(int)); x = 1;
        }
        printf("%d", x);
        return 0;
    }
    ```
    * 答案：32 либо 312 либо 321

    9. Что будет выведено на экран? Если возможны несколько вариантов – привести все.Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main() {
        pid_t pid;
        int fd[2];
        int x = 9;
        pipe(fd);
        if( (pid = fork()) > 0 ) { 
            printf("%d", x - 1);
            read(fd[0], &x, sizeof(int));
            kill(pid, SIGKILL);
            wait(NULL);
        } else { 
            x = 6;
            printf("%d", x);
            x = 3;
            write(fd[1], &x, sizeof(int));
            x = 7;
        }
        printf("%d", x);
        return 0;
    }
    ```
    Поясните свой ответ.
    * 答案：
    ```c
    863
    683

    8673
    6873

    6783
    ```


21. 程序输出，关于POSIX消息队列
    1. Что будет выведено на экран в результате работы фрагмента программы? Если возможны несколько вариантов – привести все.Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    msgId – идентификатор существующей пустой очереди сообщений.
    ```c
    struct{
        long type;
        char data[1];
    } msg;
    ……..
    msg.type = 1; msg.data[0] = 'a'; msgsnd(msgId, &msg, 1, 0);
    msg.type = 2; msg.data[0] = 'b'; msgsnd(msgId, &msg, 1, 0);
    msg.type = 2; msg.data[0] = 'c'; msgsnd(msgId, &msg, 1, 0);
    msg.type = 1; msg.data[0] = 'd'; msgsnd(msgId, &msg, 1, 0);
    msgrcv(msgId, &msg, 1, 2, 0); putchar(msg.data[0]); 
    msgrcv(msgId, &msg, 1, 0, 0); putchar(msg.data[0]);
    msgrcv(msgId, &msg, 1, 1, 0); putchar(msg.data[0]);
    ……
    ```
    * 答案：bad

    2. Что будет выведено на экран в результате работы фрагмента программы? Если возможны несколько вариантов – привести все.Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    msgId – идентификатор существующей пустой очереди сообщений.
    ```c
    struct {
        long type;
        char data[1];
        } msg;
    ……..
    msg.type = 1; msg.data[0] = '1'; msgsnd(msgId, &msg, 1, 0);
    msg.type = 2; msg.data[0] = '2'; msgsnd(msgId, &msg, 1, 0);
    msg.type = 2; msg.data[0] = 'a'; msgsnd(msgId, &msg, 1, 0);
    msg.type = 1; msg.data[0] = 'b'; msgsnd(msgId, &msg, 1, 0);
    msgrcv(msgId, &msg, 1, 2, 0); putchar(msg.data[0]); 
    msgrcv(msgId, &msg, 1, 0, 0); putchar(msg.data[0]);
    msgrcv(msgId, &msg, 1, 1, 0); putchar(msg.data[0]);
    ```
    * 答案：21b

    3.  Что будет выведено на экран в результате работы фрагмента программы? Если возможны несколько вариантов – привести все.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    msgId – идентификатор существующей пустой очереди сообщений.
    ```c
    struct {
        long type;
        char data[1];
    } msg;
    ……..
    msg.type = 1; msg.data[0] = 'x'; msgsnd(msgId, &msg, 1, 0);
    msg.type = 2; msg.data[0] = 'y'; msgsnd(msgId, &msg, 1, 0);
    msg.type = 2; msg.data[0] = 'z'; msgsnd(msgId, &msg, 1, 0);
    msg.type = 1; msg.data[0] = 't'; msgsnd(msgId, &msg, 1, 0);
    msgrcv(msgId, &msg, 1, 2, 0); write(1, msg.data[0], 1); 
    msgrcv(msgId, &msg, 1, 1, 0); write(1, msg.data[0], 1);
    msgrcv(msgId, &msg, 1, 0, 0); write(1, msg.data[0], 1);
    ……
    ```
    * 答案：yxz

22. 程序输出，关于fork和管道
    1. Что будет выведено на экран? Если возможны несколько вариантов– привести все. Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main(){
        char c;
        int fd[2], fd2[2];
        pipe(fd); pipe(fd2);
        if(fork() == 0) { 
            write(fd[1], &c, 1); 
            putchar('d'); 
            read(fd2[0], &c, 1); 
            putchar('b'); exit(0);
        }
        putchar('a'); read(fd[0], &c, 1); 
        putchar('c'); write(fd2[1], &c, 1); 
        wait(NULL);
        putchar('f'); return 0;
    }   
    ```
    * 答案：acdbf либо adcbf либо dacbf

    8. Что будет выведено на экран? Если возможны несколько вариантов – привести все. Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main() {
        char c = '1';
        int fd[2], fd2[2];
        pipe(fd); pipe(fd2);
        if(fork() == 0) { 
            write(fd[1], &c, 1);
            putchar('2');
            read(fd2[0], &c, 1);
            putchar('3');
            exit(0); 
        }
        putchar('4'); 
        read(fd[0], &c, 1);
        putchar('5');
        write(fd2[1], &c, 1);
        wait(NULL);
        putchar('6');
        return 0;
    }
    ```
    * 答案：
    ```c
    45236 
    либо
    24536
    либо
    42536
    ```

23. 关于信号量的代码，从列出的输出中选出不可能发生的选项
    1. Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.Вычеркните варианты вывода, невозможные при выполнении фрагментов программ тремя параллельными процессами (A,B,C):
    semId – идентификатор массива семафоров, состоящего из 1 семафора. Массив проинициализирован с помощью вызова: 
    ```c
    semctl(semId, 0, SETVAL, 2);
    ```
    Данный фрагмент выполняется двумя параллельными процессами (A и B):
    ```c
    struct sembuf op; op.sem_num = 0; op.sem_flg = 0; 
    op.sem_op = -1; semop(semId, &op, 1); putchar('1');
    putchar('2'); op.sem_op = 1; semop(semId, &op, 1);
    ```
    Данный фрагмент выполняется одним параллельным процессом С:
    ```c
    struct sembuf op; op.sem_num = 0; op.sem_flg = 0; 
    op.sem_op = -1; semop(semId, &op, 1); putchar('3');
    op.sem_op = 1; semop(semId, &op, 1);
    ```
    Варианты вывода:
    1) 12213
    2) 12123
    3) 11232
    4) 11322
    5) 11223
    6) 31212

    * 答案：
    Невозможные варианты вывода:
    1) 12213
    4) 11322


    3. Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.Вычеркните варианты вывода, невозможные при выполнении фрагментов программ тремя параллельными процессами (X,Y,Z):
    semId – идентификатор массива семафоров, состоящего из 1 семафора. Массив проинициализирован с помощью вызова: 
    ```c
    semctl(semId, 0, SETVAL, 2);
    ```
    Данный фрагмент выполняется двумя параллельными процессами (X и Y):
    ```c
    struct sembuf op; op.sem_num = 0; op.sem_flg = 0; 
    op.sem_op = -1; semop(semId, &op, 1); putchar('a');
    putchar('b'); op.sem_op = 1; semop(semId, &op, 1);
    ```
    Данный фрагмент выполняется одним параллельным процессом Z:
    ```c
    struct sembuf op; op.sem_num = 0; op.sem_flg = 0; 
    op.sem_op = -1; semop(semId, &op, 1); putchar('c');
    op.sem_op = 1; semop(semId, &op, 1);
    ```
    Варианты вывода:
    1) abbac
    2) ababc
    3) aabcb
    4) aacbb
    5) aabbc
    6) cabab

    * 答案：
    Невозможные варианты вывода:
    1) abbac
    4) aacbb

24. 另一类信号量的代码，写出可能出现的所有选项
    2. Что будет выведено на экран? Если возможны несколько вариантов – привести все.Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    semId – идентификатор массива семафоров, состоящего из 1 семафора 
    Массив проинициализирован с помощью вызова: 
    ```c
    semctl(semId, 0, SETVAL, 8);
    ```
    Фрагмент программы выполняется 3-мя параллельными процессами:
    ```c
    struct sembuf op; op.sem_num = 0; op.sem_flg = 0;
    op.sem_op = -3; semop(semId, &op, 1);
    write(1, "1", 1); write(1, "2", 1);
    op.sem_op = 2; semop(semId, &op, 1);
    ```
    * 答案：
    Варианты:
    121212
    121122
    112122
    112212

    6. Какие средства синхронизации можно выбрать и какие действия вставить в эту программу, чтобы сначала напечаталось AВ, потом CD или DC (оба варианта должны быть возможны)?
    ```c
    int main(void) {
        if (fork()) {
            write(1, “A”, 1);
            write(1, “C”, 1);
            wait(NULL);
        } else {
            write(1, “B”, 1);
            write(1, “D”, 1);
        }
    }
    ```
    * 答案：
    Можно использовать семафор:
    ```c
    int main(void) {
        semaphore s = 0;
        if (fork()) {
            write(1, “A”, 1);
            up(&s, 1);
            down(&s, 2);
            write(1, “C”, 1);
            wait(NULL);
        } else {
            down(&s, 1);
            write(1, “B”, 1);
            up(&s, 2);
            write(1, “D”, 1);
        }
    }
    ```

    9. Опишите словесно все варианты вывода на экранПредполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main()
    {
        int fd[2];
        char c[2];
        pipe(fd);
        write(fd[1], c, 2);
        fork();fork();fork();fork();
        read(fd[0], c, 1);
        write(1, "a", 1);
        write(1, "b", 1);
        write(fd[1], c, 1);
        wait(NULL);
        return 0;
    }
    ```
    * 答案：
    Будет выведена последовательность из a и b длиной в 32 символа, в которой содержится по 16 символов a и b. Любой префикс выводимого программой ответа будет начинаться с ‘a’, а разница между количеством ‘a’ и количеством ‘b’ в любом префиксе не меньше нуля и не больше двух.



25. 关于fork和管道的代码，列出所有可能输出
    2. Что будет выведено на экран? Если возможны несколько вариантов – привести все.Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main() {
        int fd[2];
        char c[2] ="34";
        pipe(fd);
        write(fd[1], c, 2);
        if(fork()) fork();
        read(fd[0], c, 1);
        write(1, "1", 1);
        write(1, "2", 1);
        write(fd[1], c, 1);
        wait(NULL);
        return 0;
    }
    ```
    * 答案：
    Варианты:
    121212
    121122
    112122
    112212

    3. Что будет выведено на экран? Если возможны несколько вариантов – привести все.Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main(){
        int fd[2];
        char c[2] ="34";
        pipe(fd);
        write(fd[1], c, 2);
        if (fork())
        fork();
        fork(); fork();
        read(fd[0], c, 2);
        write(1, "a", 1);
        write(1, "b", 1);
        write(fd[1], c, 2);
        wait(NULL);
        return 0;
    }
    ```
    * 答案：
    Будет выведена последовательность пар ab длиной 12 (всего 24 символа)


26. 关于多次fork和管道的代码，列出所有可能输出
    1. Что будет выведено на экран? Если возможны несколько вариантов – привести все.Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main()
    {
        int fd[2];
        pipe(fd);
        char x[] = "ba\n";
        if(fork()) { 
            puts(x + 1); write(fd[1], x, 1); 
            wait(NULL);
        } else { 
            write(fd[1], &x[1], 1); read(fd[0], x, 1); 
            read(fd[0], x+1, 1);
        }
        puts(x); return 0;
    }
    ```
    * 答案：
    a 
    ba 
    ba 
    либо
    a
    ab
    ba

    3. Что будет выведено на экран? Если возможны несколько вариантов – привести все.Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main() {
        int fd[2];
        pipe(fd);
        char x[] = "dc\n";
        if(fork()) { 
            puts(x + 1); 
            write(fd[1], x, 1); 
            wait(NULL);
        } else { 
            write(fd[1], &x[1], 1); 
            read(fd[0], x, 1); 
            read(fd[0], x+1, 1); 
        }
        puts(x); return 0;
    }
    ```
    * 答案：
    c
    dc
    либо
    c
    cd
    dc

27. 关于字符串，fork和管道的代码，描述进程会发生什么
    1. Описать, что произойдет с процессами и почему (все системные вызовы отрабатывают корректно – без отказов)
    ```c
    int main(int argc, char **argv) 
    {
        int fd[2];
        char c[2] = "ab";
        pipe(fd); 
        if(fork()) { /* процесс №1 */
            close (fd[0]);
            close (fd[1]);
        } else { /* процесс №2 */
            read(fd[0], c,1);
        }
    }
    ```
    * 答案：
    Процесс № 1: завершится. 
    Процесс № 2: зависнет, т.к. в системе не будет закрыт дескриптор записи в этот канал (дескриптор, который был унаследован процессом №2).

    3. Описать, что произойдет с процессами и почему (все системные вызовы отрабатывают корректно – без отказов)
    ```c
    int main(void) 
    {
        int fd[2];
        char c[] = "abc\n";
        if(fork() == 0) { /* процесс №1 */
            close (fd[0]);
            close (fd[1]);
        } else { /* процесс №2 */
            read(fd[0], &c, 2);
        }
    }
    ```
    * 答案：
    Поведение не определено, т.к. не инициализирован массив fd.

    5. Описать, что произойдет с процессами и почему (все системные вызовы отрабатывают корректно – без отказов)
    ```c
    int main(int argc, char **argv){
        int fd[2];
        char c[2] = "ab";
        pipe(fd); 
        if(fork()) {/*процесс №1*/
            close (fd[0]);
            close (fd[1]);
            wait(NULL);
        } else {/*процесс №2*/
            read(fd[0],c,1);
            close(fd[1]);
        }
    }
    ```
    * 答案：
    Процесс № 2: зависнет, т.к. в системе не будет закрыт дескриптор записи в этот канал (дескриптор, который был унаследован процессом №2).
    Процесс № 1: зависнет в ожидании завершения процесса № 2.


28. 关于文件，dup,lseek等的多进程代码,列出所有可能的输出并解释
    1. Содержимое файла “1.txt” – строка «abcde». Что будет выведено на экран? Если возможны несколько вариантов – привести все.Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main()
    {
        char c = 'a';
        int fd; 
        fd = open("1.txt", O_RDONLY);
        if(fork()){
            int fd2 = open("1.txt", O_RDONLY);
            int fd3 = dup(fd);
            lseek(fd, 2, SEEK_CUR);
            wait(NULL);
            read(fd2, &c, 1); write(1, &c, 1);
            read(fd3, &c, 1); write(1, &c, 1); 
        }else{ 
            read(fd, &c, 1); write(1, &c, 1); 
        }
        return 0;
    }
    ```
    * 答案：
        Ответ: aad либо cad

        Два варианта порождаются за счет «гонок» между lseek и read в «сыне». Сам вывод определяется тем, что при «наследовании» и дублировании файлового дескриптора файловый указатель является общим, а при open создается новый.


    3. Содержимое файла “1.txt” – строка «123456». Что будет выведено на экран? Если возможны несколько вариантов – привести все.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main(void)
    {
        char c = '0';
        int fd = open("1.txt", O_RDONLY);
        if(fork() == 0) {
            read(fd, &c, 1); write(1, &c, 1);
        } else {
            int fd2 = open("1.txt", O_RDONLY);
            int fd3 = dup(fd);
            lseek(fd, 2, SEEK_CUR);
            wait(NULL);
            read(fd2, &c, 1); write(1, &c, 1);
            read(fd3, &c, 1); write(1, &c, 1); 
        }
        return 0;
    }
    ```
    * 答案：
        Два варианта порождаются за счет «гонок» между lseek и read в «сыне». Сам вывод определяется тем, что при «наследовании» и дублировании файлового дескриптора файловый указатель является общим, а при open создается новый.
        Ответ:
        314 (lseek->read)
        114 (read -> lseek)


    8. Описать, что произойдет с процессами и почему (все системные вызовы отрабатывают атомарно и корректно – без отказов). Что будет выведено на экран? Если допустимы несколько вариантов вывода, приведите все.
    ```c
    int main(int argc, char **argv) 
    {
        int fd[2], buf = 10;
        pipe(fd);
        if(!fork()) {
            write (fd[1], &buf, sizeof(int)); buf++; 
            printf("%d\n", buf);
        } else { 
            while(read(fd[0], &buf, sizeof(int))) {
                buf--; printf("%d\n", buf);
            }
        }
        return 0;
    }
    ```
    * 答案：
        1. Сыновий процесс выполнит действия и завершится.
        2. Родительский процесс считает информацию из канала, выведет на экран «9» и зависнет (в нем не закрыт «пишуший» дескриптор канала и read будет ожидать его закрытия).
        
        На экран будет выведено:
        11
        9
        ИЛИ
        9
        11

29. 文件系统和机械硬盘寻道的问题
    1. В файловой системе используются битовые массивы для хранения информации о свободных и занятых блоках. Написать на Си функцию, принимающую в качестве параметров указатель на начало этого битового массива (последовательность байтов), номер блока файловой системы (нумерация с нуля), максимально возможный номер блока и возвращающую статус занятости этого блока: 0 –свободен, 1 занят, -1 – номер вне диапазона.
    * 答案：
    ```c
        // Предположим, CHAR_BIT == 8
        int is_free(unsigned char *BitBlocks, unsigned Num, 
        unsigned Max_Num) {
            if (Num > Max_Num) {
                return -1;
            } else {
                return (BitBlocks[Num >> 3] >> (7 - (Num & 7u))) & 1;
            }
        }
    ```

    2. Головка HDD находится на дорожке 100. Нужно выполнить следующие запросы к дорожкам:60, 5, 22, 83, 120, 71.Назвать последовательность запросов при использовании жадного алгоритма.
    * 答案：
        На каждом шаге выбираем ближайшую дорожку. 
        Получаем: 83, 71, 60, 22, 5, 120.

    3. Головка HDD находится на дорожке 90. Нужно выполнить следующие запросы к дорожкам:104, 20, 95, 56, 81, 3.Назвать последовательность запросов при использовании жадного алгоритма.
    * 答案：
        На каждом шаге выбираем ближайшую дорожку. 
        Получаем: 95, 104, 81, 56, 20, 3.

    4. Перечислите все ситуации, в которых системный вызов open(“/home/ira/dir/file”, O_RDONLY) может вернуть -1.
    * 答案：
        Замечание: не надо требовать перечислить ВСЕ ошибки, возникающие в ходе выполнения open, их в man – около 20. Достаточно назвать 3-4 различных ситуации, например:
        - файла /home/ira/dir/file нет
        - какая-то из директорий в пути /home/ira/dir/file отсутствует или недоступна
        - пользователь не имеет прав на чтение файла /home/ira/dir/file
        - в процессе нет доступных файловых дескрипторов для открытия
        - превышен системный лимит на число открытых файлов
        - файл /home/ira/dir/file заблокирован для чтения др.

    5. Перечислите все ситуации, в которых системный вызов execl(“/home/igor/dir/prog”) может вернуть -1.
    * 答案：
        Замечание: не надо требовать перечислить ВСЕ ошибки, возникающие в ходе выполнения exec, их в man – около 20. Достаточно назвать 3-4 различных ситуации, например:
        - файла /home/igor/dir/prog нет
        - какая-то из директорий в пути /home/igor/dir/ отсутствует или недоступна
        - пользователь не имеет прав на выполнение файла /home/igor/dir/prog
        - файл /home/igor/dir/prog не является исполняемым
        - файл /home/igor/dir/prog является исполняемым, но имеет неверный формат
        - в процессе нет доступных файловых дескрипторов для открытия
        - нет ресурсов ядра для загрузки нового тела процесса
        - файл /home/igor/dir/prog заблокирован для чтениядр.

    6. Пусть в некоторой ОС используется файловая система, использующая FAT. Для представления номера блока в системе используется беззнаковое целое. Написать функцию, которая по номеру начального блока файла (положительное целое число) определяет размер файла в блоках. Функция принимает в качестве параметров номер начального блока файла и указатель на область памяти, в которой находится FAT.
    * 答案：
        i-ая строка таблицы FAT хранит информацию о состоянии i-ого блока файловой системы, а, кроме того, в ней указывается номер следующего блока файла. Для получения списка блоков файловой системы, в которых хранится содержимое конкретного файла, необходимо найти номер начального блока, а затем, последовательно обращаясь к таблице размещения и извлекая из каждой записи номер следующего блока, дойти до ссылки на нулевую строку таблицы. Нулевая строка таблицы уже не относится к рассматриваемому файлу.
        ```c
        int calculateSize(unsigned int num, unsigned int *fat)
        {
            int counter = 0;
            while (num != 0) {
                num = fat[num];
                counter++;
            }
            return counter;
        }
        ```

30. 调用函数时会访问文件描述符多少次？解释每一次是做什么
    1. Сколько раз система обратится к содержимому индексных дескрипторов при вызове: open("/dir/dir/file", O_RDONLY) ?Прокомментировать, почему? Считаем, что ни один из элементов пути к файлу не является символической ссылкой.
    * 答案：4 раза. 
        1 - дескриптор для / - чтобы найти дескриптор для файла каталога dir
        2 - дескриптор для /dir - чтобы найти дескриптор для файла каталога /dir/dir
        4 - дескриптор для /dir/dir/ - чтобы найти дескриптор для файла /dir/dir/ file
        5 - дескриптор для /dir/dir/file – чтобы проверить права доступа для этого файла и последующего чтения в память.

    2. Сколько раз система обратится к содержимому индексных дескрипторов при вызове: open("/dir1/dir2/dir3/file", O_RDONLY)?Прокомментировать, почему? Считаем, что ни один из элементов пути к файлу не является символической ссылкой.
    * 答案：5 раз. 
        1 - дескриптор для / - чтобы найти дескриптор для файла каталога dir1
        2 - дескриптор для /dir1 - чтобы найти дескриптор для файла каталога /dir1/dir2
        3 - дескриптор для /dir1/dir2 - чтобы найти дескриптор для файла каталога /dir1/dir2/dir3
        4 - дескриптор для /dir1/dir2/dir3 - чтобы найти дескриптор для файла /dir1/dir2/dir3/file
        5 - дескриптор для /dir1/dir2/dir3/file – чтобы проверить права доступа для этого файла и последующего чтения в память.

    3. Сколько раз система обратится к содержимому индексных дескрипторов при вызове: open("/dir1/file", O_RDONLY) ?Прокомментировать, почему? Считаем, что ни один из элементов пути к файлу не является символической ссылкой.
    * 答案：3 раза. 
        1 - дескриптор для / - чтобы найти дескриптор для файла каталога dir1
        2 - дескриптор для /dir1 - чтобы найти дескриптор для файла /dir1/file
        3 - дескриптор для /dir1/file – чтобы проверить права доступа для этого файла и последующего чтения в память.

    4. Сколько индексных дескрипторов нужно прочитать, чтобы загрузить файл /usr/exm/file.dat ?Считаем, что ни один из элементов пути к файлу не является символической ссылкой.
    * 答案：4

    5. Сколько индексных дескрипторов нужно прочитать, чтобы загрузить файл /home/program/dz/files/task.c ?Считаем, что ни один из элементов пути к файлу не является символической ссылкой.
    * 答案：6

