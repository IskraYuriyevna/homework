1. 奇偶校验
    * 根据进制将数字转为多位二进制，如八进制就是三位二进制数字，而16进制就是4位二进制数字，然后按照其中的1的数量加上最后一位，奇数为1,偶数为0.

    1. В оперативном запоминающем（随机存储器） устройстве 16-разрядного（16位） компьютера используется контроль целостности（完整性） данных по четности（奇偶性）. Описать возможную структуру ячейки памяти и ее побитовое（按位） содержимое для случая хранения в машинном слове восьмеричного（八进制的） числа (17735)8.
    * 答案:(17735)8. Посчитаем число двоичных единиц в каждой восьмеричной цифре: 1 + 3 + 3 + 2 + 2 = 11, число нечетное. Тогда бит паритета равен 1. Структура ячейки памяти: 16 бит данных (0001111111011101) + 1 бит паритета (1), который вычисляется как сумма по модулю 2 (XOR) всех битов данных. 

    4. В оперативном запоминающем устройстве 16-разрядного компьютера используется контроль целостности данных по четности. Описать возможную структуру ячейки памяти и ее побитовое содержимое для случая хранения в машинном слове четверичного（四进制的） числа (1033231)4.
    * 答案：(1033231)4. Посчитаем число двоичных единиц в каждой четверичной цифре: 1 + 0 + 2 + 2 + 1 + 2 + 1 = 9, число нечетное. Тогда бит паритета равен 1. Структура ячейки памяти: 16 бит данных (0001001111101101) + 1 бит паритета (1), который вычисляется как сумма по модулю 2 (XOR) всех битов данных. 

    6. В оперативном запоминающем устройстве 32-разрядного компьютера используется контроль целостности данных по нечетности. Описать возможную структуру ячейки памяти и ее побитовое содержимое для случая хранения в машинном слове 16-ичного числа (FF001077)16
    * 答案：(FF001077)16. Посчитаем число двоичных единиц в каждой ненулевой 16-ичной цифре: 4 + 4 + 1 + 3 + 3 = 15, число нечетное. Тогда бит паритета равен 1. Структура ячейки памяти: 32бита данных (11111111000000000001000001110111) + 1 бит паритета (1), который вычисляется как сумма по модулю 2 (XOR) всех битов данных.

2. RAM地址分层
    * 首先按照给出的进制转换为二进制数，然后根据по n банкам，计算出a=log2(n)，最后a位二进制数就是答案，并且转化为十进制。
    * 也就是说по 16 банкам就是最后4位，по 8 банкам就是最后3位。

    1. Пусть дано восьмеричное число (173357)8, являющееся адресом оперативной памяти, расслоенной по 16 банкам（内存块）. Банку с каким номером принадлежит（属于） заданный адрес?
    * 答案：(173357)8. В схеме расслоения памяти последовательные адреса размещаются в последовательных банках памяти. При 16 банках памяти за номер банка будут отвечать младшие 4 бита адреса. Они равны 1111, то есть 15. Ответ: банк памяти 15. (нумерация банков памяти с 0)

    5. Пусть дано четверичное число (323112)4, являющееся адресом оперативной памяти, расслоенной по 8 банкам. Банку с каким номером принадлежит заданный адрес?
    * 答案：(323112)4. В схеме расслоения памяти последовательные адреса размещаются в последовательных банках памяти. При 8 банках памяти за номер банка будут отвечать младшие 3 бита адреса. Они равны 110, то есть 6. Ответ: банк памяти 6. (нумерация банков памяти с 0)

    6. Пусть дано 16-ичное число (FAD1D31A)16, являющееся адресом оперативной памяти, расслоенной по 16 банкам. Банку с каким номером принадлежит заданный адрес?
    * 答案：(FAD1D31A)16. В схеме расслоения памяти последовательные адреса размещаются в последовательных банках памяти. При 16 банках памяти за номер банка будет отвечать младшая 16-ичная цифра адреса. Она равна A_16, то есть 10. Ответ: банк памяти 10. (нумерация банков памяти с 0)

3. IP地址的结构
    * IP地址的ABCDE五个类：全部都是32位二进制数，全部背下来，题目只会问ABC型
        * A: 0 + 8位网络号 + 24位主机号
        * B: 10 + 14位网络号 + 16位主机号
        * C: 110 + 21位网络号 + 8位主机号 
        * D: 1110 + 28位多播地址
        * E: 1111 + 28位保留到今后使用

    1. Дан 32-разрядный IP адрес, имеющий в восьмеричном представлении вид: (23171171543)8. Определить: к какому классу относится данный IP адрес; номер сети (в восьмеричном представлении), к которой относится IP адрес
    * 答案：(23171171543)8. 
        10011001111001001111001101100011_2
        Старшие биты адреса: 10, это сеть класса B. 
        Номер сети – следующие 14 бит, номер хоста –оставшиеся 16 бит. Тогда номер сети: 
        01100111100100_2 = 14744_8.

    4. Дан 32-разрядный IP адрес, имеющий в 16-ичном представлении вид: (DF00BE20)16. Определить: к какому классу относится данный IP адрес; номер сети (в 16-ичном представлении), и десятичный номер хоста в сети, к которой относится IP адрес
    * 答案：(DF00BE20)16. 
        11011111000000001011111000100000_2
        Старшие биты адреса: 110, это сеть класса С. 
        Номер сети – следующие 21 бит, номер хоста –оставшиеся 8 бит. Тогда номер сети: 
        111110000000010111110_2 = 1F00BE_16, а номер хоста – 32_10 (20_16).

4. 进程调度，问代码输出
    * fork之后的内容所有进程都会有，父进程和子进程都有可能先执行，如果没有判断pid,那么第二次fork会产生两个新进程：父进程的第二子和子进程的第一子。
    * 如果父进程先结束（比如exit(0)）了，子进程将会变成孤儿进程，其ppid为1
    * getppid();是获得父进程的进程号，getpid();是获得当前进程的进程号

    1. Пусть процесс с PID A породил два сыновьих процесса с PID-ами B и C:
    ```c
    int main(int argc, char **argv) //PID = A
    {
        if (fork() == 0){ //PID = B
            printf ("%d %d\n", getppid(), getpid());
            exit(0);
        }
        if (fork() == 0){ //PID = C
            printf ("%d\n", getpid());
            exit(0); 
        }
        return 0; 
    }

    ```
    Считаем, что printf работает атомарно и обращения ко всем системным вызовам успешно отрабатывают. Перечислить все возможные комбинации значений, которые могут быть выведены на стандартное устройство вывода в результате выполнения данной программы. 
    我们假设printf以原子方式工作，并且成功处理所有系统调用（也就是fork，pipe和内存分配这些都不会以异常退出）。列出 可以作为运行此程序的结果 输出到标准输出设备 的值 的所有可能组合。
    * 答案：
    ```c
    A B
    C
    либо
    1 B
    C
    либо 
    C
    A B
    либо 
    C
    1 B
    ```

    4. Пусть процесс с PID 4123 породил два сыновних процесса с PID-ами 4124 и 4125:
    ```
    int main(int argc, char **argv) //PID = 4123 
    {
        if (fork() == 0){ //PID = 4124
            printf ("%d \n", getpid());
            exit(0); 
        }
        wait(NULL);
        if (fork() == 0){ //PID = 4125
            printf ("%d %d \n", getpid(), getppid());
            exit(0); 
        }
        return 0; 
    }
    ```
    Считаем, что printf работает атомарно и обращения ко всем системным вызовам успешно отрабатывают. Перечислить все возможные комбинации значений, которые могут быть выведены на стандартное устройство вывода в результате выполнения данной программы. 
    * 答案： 
    ```c
    4124
    4125 4123
    либо
    4124
    4125 1
    ```

5. System V文件系统
    * 我也搞不明白，甚至很难查到资料，抽到算你倒霉吧

    1. Пусть дана（给出） файловая система Unix System V и в ней утеряна（丢失了） информация суперблока. Предложить（建议） последовательность действий（操作，行动）, позволяющую（允许，用于） восстановить（还原，恢复） содержимое（内容） файлов данной файловой системы. Считаем（我们认为）, что до потери（丢失，损失） суперблока содержимое файловой системы было корректным（正确的）. Размер（大小） суперблока, размер и структура（结构） индексного（索引） дескриптора（描述符） известны（是已知的）.
    * 答案：Структура файловой системы версии System V:
        {Суперблок} + {Область индексных дескрипторов} + {Блоки файлов}.超级块 + 索引描述符区域 + 文件块
        Размер области индексных дескрипторов хранится в суперблоке. При потере информации суперблока, данное значение теряется（迷失，丢失）. 
        1. Для восстановления（恢复） содержимого файлов, необходимо（必须） определить границу между областью（区域） индексных дескрипторов и областью блоков файлов. Идем итеративно（迭代） от начала  индексных дескрипторов. Считываем（我们读取） очередной（下一个） ID.
        2. Проверяем（我们检查） содержимое（内容） поля（字段） «ссылки на данный ID каталогов（目录） файловой системы». Если это поле равно нулю (это означает（意味着）, что ID свободен（空闲的）) переходим（转换到） к следующему ID. 
        3. В противном случае（否则的话） последовательно（依次） просматриваем（查看） 13 элементов, описывающих（描述） адресацию（地址，寻址） блоков файла (до завершения（完成）): номера блоков с прямой（直接的） адресацией (10 шт.), номера блоков, организованных（有组织的） с косвенной（间接的） адресацией 1, 2 и 3-х уровневой（等级）. 
        4. В случае, если получен некорректный номер блока, завершаем（终止） алгоритм（算法） (область индексных дескрипторов закончилась). Альтернативой（另一种选择，替代方案） проверки（检查） поля（字段） со ссылками может являться проверка содержимого（内容） поля «тип файла»（文件类型）: если оно является некорректным, то это так же означает, что область индексных дескрипторов закончилась.

    2. Описать алгоритм определения（定义） размера файла в блоках по содержимому（内容） массива（数组） адресации（地址） блоков файла индексного（索引） дескриптора（描述符） (модельной（模型） Unix системы).Считаем（我们假设）, что массив состоит из элементов беззнакового целого.Размер блока – 2048 байт. 
    Считаем, что доступ（访问） к блокам файловой системы осуществляется посредством（他是被由...实现的） использования внешней（外部的） функции GetBlockFS, которая принимает（接受） в качестве（作为） параметра（参数，变量） номер блока файловой системы, который нужно считать, а возвращает（返回） указатель на считанный（读取的） блок.
    В решении（解决） предположить（方案）, что признаком окончания файла является 0 в массиве номеров блоков файла (отметим（注意）, что в общем（一般） случае это не гарантируется（保证）).
    * 答案：
        1. Вначале рассчитываем（计算）, сколько четырехбайтовых чисел (unsigned int) поместится（适合，在） в одном блоке:
        tmp = 2048 / sizeof(unsigned int) = 2048 / 4 = 512.
        2. Далее сначала рассматриваем первые 10 элементов массива адресации. Если встречаем（遇到） 0, то останавливаемся（停下来）. Рассматриваем 11-ый элемент. Если он равен нулю, то останавливаемся. 
        3. Иначе（否则） при помощи функции GetBlockFS получаем указатель на следующий блок, содержащий（内容包含） 512 номеров блоков.Также их проверяем на ноль. 
        4. Если не остановились, то переходим（转到） к 12-ому элементу, не забываем, что здесь уже косвенная（间接） адресация（寻址） второго уровня (данный элемент ссылается（指向的，连接到的） на массив из 512 ссылок, каждая из которых ссылается на массив из 512 блоков файла). 
        5. Далее, если не остановились, переходим к 13-ому элементу (где косвенная адресация уже третьего уровня).

    3. Как работает системный вызов（调用） open(filename, openmode, flags)?
    * 答案：
        1. Открывает файл с именем filename, режимом（模式） доступа（访问） openmode. Если openmode позволяет（允许） создание файла и файл не существует, то файл создается с правами（权限） flags;
        2. Устанавливается（安装，建立） связь（连接） с индексным（索引） дескриптором（描述符）, или создается новый ИД（ID）;
        3. Добавляется（添加） новая запись（条目） в ТОФ ОС（操作文件表）(указатель смещения（偏移量） в файле для чтения（读） / записи（写） и ссылка（链接） на ИД);
        4. Добавляется запись в ТОФ процесса (ссылка на запись в ТОФ ОС);
        5. Индекс（索引） данной（给出的） записи в ТОФ процесса возвращается（返回） как файловый дескриптор открытого файла.

6. IP地址的结构 
    * 和问题3一样，背下来
    * 其中<код_класса>类型码，<номер_сети>是网络号，<номер_компьютера_в_сети>是主机号

    1. Какова структура IP адреса класса С (описать все поля（字段） и их размеры（大小）)?
    * 答案：
    <код_класса><номер_сети><номер_компьютера_в_сети>
    <код_класса> – 110 (3 бита)
    <номер_компьютера_в_сети> – один байт
    <номер_сети> – оставшееся в IP адресе пространство (крайние левые три байта IP адреса без крайних левых трех битов)

    2. Какова структура IP адреса класса B (описать все поля и их размеры)?
    * 答案：
    <код_класса><номер_сети><номер_компьютера_в_сети>
    <код_класса> – 10 (2 бита)
    <номер_компьютера_в_сети> – 2 байта
    <номер_сети> – оставшееся в IP адресе пространство (крайние левые два байта IP адреса без крайних левых двух битов)

    3. Какова структура IP адреса класса A (описать все поля и их размеры)?
    * 答案：
    <код_класса><номер_сети><номер_компьютера_в_сети>
    <код_класса> – 0 (1 бит)
    <номер_компьютера_в_сети> – 3 байта
    <номер_сети> – оставшееся в IP адресе пространство, 7 битов

    4. Какова структура IP адреса класса D (описать все поля и их размеры)?
    * 答案：
    <код_класса><группа>
    <код_класса> – 1110 (4 бита)
    <группа> – оставшееся в IP адресе пространство (32 – 4 = 28 битов)

    5. Сколько байтов в структуре IP-адреса класса C отводится под номер компьютера?Где они расположены?
    * 答案：
    <код_класса><номер_сети><номер_компьютера_в_сети>
    Один байт, крайний справа


7. 进程通讯，问代码输出
    * 跟前面差不多，注意管道不管多少字节都可以传输，但是写入多少字节要看的write的第三个参数
    * write()的三个参数，第一个是写的目标地点，第二个是写的内容，第三个是写的字节数
    * puts(x+1);中相当于将x,也就是指向字符串的指针后移一个元素再打印，也就是打印字符串的第二个字符

    1. Что будет выведено на экран? Если возможны несколько вариантов – привести все. Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации. Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    屏幕上会显示什么？给出所有可能的情况。假设访问显示功能以原子方式工作，并且没有缓冲。所有系统调用都成功处理。头文件的链接被省略。
    ```c
    int main()
    {
        int fd[2];
        pipe(fd);
        char x[] = "01\n";
        if(fork()) {
            puts(x + 1);
            write(fd[1], x, 1);
            wait(NULL);
        } else {
            write(fd[1], &x[1], 1);
            read(fd[0], x, 1);
            read(fd[0], x+1, 1);
        }
        puts(x);
        return 0;
    }
    ```
    * 答案：
    ```c
    1 
    01 
    01 
    либо
    1
    10
    ```

    11. Что будет выведено на экран? Если возможны несколько вариантов – привести все. Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации. Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main() {
        int fd[2];
        pipe(fd);
        char x[] = "qw\n";
        if(fork()) {// pid=A
            write(fd[1], x, 1);
            wait(NULL);
        } else { //pid=B
            write(fd[1], &x[1], 1);
            read(fd[0], x, 1);
            read(fd[0], x+1, 1);
        }
        printf("%d ", getpid()); 
        puts(x);
        return 0;
    }
    ```
    * 答案：
    ```c
    B qw 
    A qw 
    либо
    B wq
    A qw
    ```

8. I/O，面向字符和面向块的I/O
    * 概念题

    1. Может ли одно и то же физическое устройство быть представлено в системе и как байт-ориентированное устройство и как блок-ориентированное? Ответ обосновать.
    同一个物理设备 是否可以在系统中 同时表示为 面向字符的设备 和 面向块的设备？ 给出并解释你的答案。
    * 答案：Может. Регистрируются 2 файла устройств, связанных с данным устройством. Один файл – байт-ориентированное устройство (связано（链接） с соответствующим（适当的） драйвером（驱动程序）), другой – блок-риентированное устройств

    2. Привести 2 примера байт-ориентированных устройств.给出面向字符的设备的2个示例。
    * 答案：Клавиатура, мышь （键盘，鼠标）（其实还有显示器，打印机等）
    
    3. Привести 3 примера блок-ориентированных устройств.给出面向块的设备的3个示例
    * 答案：Флэш-накопитель, жесткий диск, накопитель на магнитной ленте（闪存驱动器，硬盘驱动器，磁带驱动器）

    4. Верно ли, что любое физическое устройство представлено в системе и как байт-ориентированное устройство и как блок-ориентированное? Ответ обосновать.
    在系统中，任何物理设备都表示为 面向字符的设备 和 面向块的设备，这样说对吗？ 解释你的答案。
    * 答案：Нет. Не для всех устройств оба варианта имеют смысл. Например, для датчика（传感器） температуры блочное（块） представление（表示） не нужно.

9. 进程，wait()，问代码输出
    * wait(0)和wait(NULL)都是将父进程挂起，并等待子进程退出

    1. Что будет выведено（显示） на экран, если PID изначально запущенного（运行） процесса равен 1277? Если возможны несколько вариантов – привести все варианты. Предполагается（假设）, что все системные вызовы（调用） прорабатывают（处理） успешно（成功）. Подключение（连接） заголовочных файлов опущено（省略）.
    ```c
    int main()
    {
        int pid;
        if (fork() == 0) {
            printf ("PPID = %d \n", getppid());
        } else {
            exit(0);
        }
    }
    ```
    * 答案：PPID=1277 или PPID=1

    5. Что будет выведено на экран, если PID изначально запущенного процесса равен A, а PID запущенных процессов - B или C? Если возможны нескольковариантов – привести все варианты. Предполагается, что все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main() {
        if(fork()==0) // B
        if(fork()==0){ // C
            printf ("PPID1=%d\n",getppid());
        }else{
            printf ("PPID2=%d\n",getppid());
            wait(NULL); exit(0);
        }else // A
        exit(0); 
    }
    ```
    * 答案：
    ```c
    PPID1=B
    PPID2=A
    или
    PPID2=A
    PPID1=B
    или
    PPID1=B
    PPID2=1
    или
    PPID2=1
    PPID1=B
    ```


10. 系统调用和库调用
    * 也是概念题

    1. Может ли пользовательский（用户的） процесс в Unix System V выполняться（运行） в режиме（模式） операционной системы? Обосновать ответ. 
    * 答案：Да. При обращении（地址） к системным вызовам
        可以，在系统调用的时候

    2. Привести примеры библиотечных функций языка С, не содержащих в своей реализации（实现） системные вызовы.
    * 答案：Большинство функций работы со строками（字符串） (например, sscanf, strlen)

    3. Чем отличается（区别） системный вызов от библиотечной функции? Вычеркнуть（删除） из списка（列表） все системные вызовы:
    ```c
    read(fd, buffer, N);
    scanf(“%d”, &i);
    sscanf(buffer, “%d”, &i);
    k = ftok(“/etc/passwd”, ‘A’);
    id = msgget(k, IPC_CREAT | 0666);
    ```
    * 答案：
        При обращении к системным вызовам процесс переходит（切换） в привилегированный（特权） режим, в котором выполняются（执行） нужные функции ядра ОС. Библиотечные функции работают в пользовательском режиме, обращаясь, если надо к системным вызовам.
        Библиотечные функции: 
        ```c
        scanf(“%d”, &i);
        sscanf(buffer, “%d”, &i);
        k = ftok(“/etc/passwd”, ‘A’);
        ```

    4. Как работает системный вызов wait(int * status)?
    * 答案：
        * Процесс блокируется（阻塞） до завершения（返回） какого-либо потомка（后代，子进程）. Если потомков нет (или всех уже дождались（等到了）), то возвращается -1;
        * удаляет завершившийся（已完成的，已经终止的） процесс-потомок из таблицы процессов;
        * статус（状态） завершения потомка записывается（写入） в *status(если указатель（指针） ненулевой（非零）);
        * возвращает pid завершенного потомка.Также при wait процесс блокируется до прихода сигнала, который либо завершит（结束） текущий процесс, либо вызовет（调用） функцию-обработчик（程序处理函数）. Если ожидание（等待） было прервано（中断） сигналом, то возвращается -1.

    5. Чем отличается системный вызов от библиотечной функции? Какие библиотечные функции ниже НЕ обращаются（处理） к системным вызовам?
    ```c
    scanf(“%d”, &i);
    sscanf(buffer, “%d”, &i);
    k = ftok(“/etc/passwd”, ‘A’);
    d = sqrt(x);
    ```
    * 答案：
        При обращении к системным вызовам процесс переходит в привилегированный режим, в котором выполняются нужные функции ядра ОС. Библиотечные функции работают в пользовательском режиме, обращаясь, если надо к системным вызовам.Библиотечные функции, которые не обращаются к системным вызовам: 
        ```c
        sscanf(buffer, “%d”, &i);
        d = sqrt(x);
        ```

    6. В каких режимах будет работать процесс при выполнении（执行） функции printf()? Обосновать ответ.
    * 答案：Частично（部分） в пользовательском (подготовка（准备） данных для вывода（输出）), частично в привилегированном（特权） (собственно（实际上） вывод（输出） через системный вызов write())

    7. В каком режиме（模式） выполняется（运行） пользовательский процесс в Unix System V при обращеии к системным вызовам（访问系统调用）?
    * 答案：В режиме операционной системы


11. 套接字
    * 概念题

    1. В системе клиент（客户端）-сервер（服务器）, реализованной（实现） с использованием сокетов（套接字）, подключены и работают три клиентских процесса. Обосновать（说明）, какое минимальное количество（数量） сокетов может быть единовременно（同时） открыто у процесса-сервера в этом случае?
    * 答案：Один, т.к. сервер для каждого подключенного клиента может формировать отдельный（单独的） процесс, после чего закрывать сокет, связанный с клиентом.

    4. В системе клиент-сервер, реализованной с использованием сокетов, работает один серверный процесс, в котором открыт 1 серверный и 3 клиентских сокета. Обосновать, какое минимальное количество клиентских процессов может единовременно работать в этом случае?
    * 答案：Ни одного клиентского процесса, т.к. сервер для каждого подключенного клиента может асинхронным（异步） образом（方式） обрабатывать（处理） соединения, не заводя（启动） для этого клиентский процесс.

    6. Каким образом можно добиться（确保） того, чтобы в системе клиент-сервер (реализованной с использованием сокетов) при работе с пятью клиентскими процессами у процесса-сервера был бы открыт только один сокет?
    * 答案：Формировать отдельный процесс для каждого подключенного клиента, затем закрывать сокет, связанный с клиентом.


12. 文件系统，文件块
    * 就是问，给定链接组成的文件系统，设文件块中的链接占用x字节，文件块的大小为y字节，需要最少多少次交换才能读懂m到n的部分文本
    * 文件块中的信息有y-x个字节，共有n/(y-x)个区块，这个答案需要向上取整。

    1. Дана файловая система, имеющая организацию в виде связанного（链） списка（表）. Пусть ссылка в файловом блоке занимает（占用） 8 байтов, а размер файлового блока равен 1024 байтам. Пусть некоторый файл из данной файловой системы содержит текстовую информацию (последовательность байтов, содержащих коды символов（字符）). За какое минимальное количество обменов（交换） можно прочесть часть текста с 2047 символа до 3072 (считаем, что нумерация（编号） символов в тексте начинается с 1). 
    * 答案：Четыре обмена

    2. Дана файловая система, имеющая организацию в виде связанного списка. Пусть ссылка в файловом блоке занимает 4 байта, а размер файлового блока равен 1024 байтам. Пусть некоторый файл из данной файловой системы содержит текстовую информацию (последовательность байтов, содержащих коды символов). За какое минимальное количество обменов можно прочесть часть текста с 2047 символа до 5172 (считаем, что нумерация символов в тексте начинается с 1).
    * 答案：Содержательная информация в файловом блоке занимает: 1024 – 4 = 1020 байтов.
        Нам надо прочитать до 5172 байта: 5172 / 1020 = 5.071 блоков.
        Таким образом, нам надо пройти 6 блоков (то есть округляем 5.071 в большую сторону), то есть выполнить 6 обменов.

13. 文件系统，文件块的恢复
    * 比较难的概念题，但还是只能背。

    1. При сверке（检查） целостности（完整性） файловой системы i-й элемент таблицы занятых блоков равен 3. А i-й элемент таблицы свободных блоков равен 5. Описать последовательность действий（操作）, восстанавливающих（恢复） системную информацию файловой системы.
    * 答案：
        Находим（找到） 3 индексных дескриптора, содержащих（包含） блок с номером i, делаем копию соответствующих（相应的） файлов, удаляем 3 оригинальных（原始的） файла, переименовываем（重命名） копии файлов в имена исходных（原版，来源） файлов, перевосстанавливаем（重装） таблицу занятых（占用的） блоков, перевосстанавливаем таблицу свободных блоков.

    2. Дать краткое（简要的） описание основных（主要） шагов（步骤） алгоритма восстановления списка свободных индексных дескрипторов файловой системы System V.
    * 答案：
        Цикл по области индексных дескрипторов. 
        Индексный дескриптор считается（被认为是） свободным, если его поле «количество ссылок из каталогов（目录） файловой системы» равно 0.

    3. Пусть в файловой системе используется модель（模型） учёта（记账，计数） свободных блоков на основе（基于） битовых массивов. Сколько блоков ФС займёт（需要） этот битовый массив для жёсткого（硬） диска объёмом（容量） в 8 Гбайт, если размер блока равен 2 Кбайт.
    * 答案：
        Диск = (8*1024*1024) / 2 = 2^22 блоков;
        2^22 бит = 2^8 * 2 Кбайт = 2^8 блоков
        也就是，先根据给出的磁盘大小和块大小计算出整个磁盘分多少块，然后按照每块占用一字节算出总共需要多少空间，最后算出这些空间是占用多少块。


14. 文件系统，归档
    * 好像不是很难的概念题。

    1. Перечислить（列出） основные шаги инкрементального（增量式） архивирования（归档） файлов.
    * 答案：
        Создание цепочки（链条） архивов（档案）: 
        1. Создаем мастер-копию архива – копия всех архивируемых（存档的） файлов. 
        2. По расписанию（时间表） создаем копии «изменений（更改）» –копия, в которой сохранены файлы, созданные или измененные с момента предыдущего（上次） архивирования.

    2. В системе, в различных процессах единовременно N кратно（次） открыт файл с именем Name – в существующих в системе процессах имеется N файловых дескрипторов（描述符）, связанных с файлом Name. Из которых К файловых дескрипторов являются унаследованными（继承的）. Какое количество записей（条）, связанных с данным файлом, имеется в Таблице файлов операционной системы?
    * 答案：
        При fork() в системе появляются（出现） новые файловые дескрипторы (в Таблицах открытых файлов сыновьих процессов), но новые записи в Таблицу файлов операционной системы не заносятся（被输入）.
        Таким образом（因此）, получаем ответ: N-k.

    3. Если файл не является символической（符号的） ссылкой, то где именно хранится ссылка на индексный дескриптор этого файла?
    * 答案：В файле каталога.

    4.  Перечислите две ситуации（情况）, в которых системный вызов fork() может вернуть（返回） -1.
    * 答案：
        * Системе не хватает（拥有足够的） ресурсов（资源） для размещения（安置） нового процесса;
        * Превышен（已经超过） лимит максимального числа процессов для пользователя или всей системы.

    5. Где именно（确切的） хранится имя файла в файловой системе?
    * 答案：В файле каталога.

    6. Перечислите три ситуации, в которых системный вызов waitpid(pid, NULL, flags) может вернуть -1.
    * 答案：
        * У процесса нет потомков（后代）, которых надо дожидаться（等待） (либо вообще не было, либо всех дождались（已经等到了）);
        * Неверный（无效的） pid;
        * Неверные флаги.

    7. Каково основное преимущество（优势） инкрементального архивирования файлов?
    * 答案：При изменении（更改） файлов добавляют только различия（差异）, не надо все заново（再一次） архивировать.

    8. Перечислить достоинства（优点） и недостатки（缺点） компрессии（压缩） при архивировании.
    * 答案：
        Достоинства: выигрыш（收益，获利） в объеме резервной копии.
        Недостатки: компрессия чувствительна（敏感） к потереинформации（信息丢失）. Потеря（丢失）/добавление（增加） одного бита может повлечь（导致） за собой порчу（损坏） всего（整个） архива（档案）.

15. 文件系统，“外部页表”包含多少个条目
    * 这个题相当于问，一台实现两级页表的x位计算机，页面大小为y字节，每个二级表的大小为n条记录，“外部页表”包含多少个条目？
    * 虚拟地址是一级页号，二级页号和页中偏移量的组合，共有x位，计算出偏移量为log2(y)位，第一级页码为log2(n)位
    * 那么第二级页码就是m = x-log2(y)-log2(n)位，最后算出外部页表包含 2^m 个条目。

    2. Пусть в 32-разрядном компьютере используется страничная（页面） память с двухуровневой（两级） таблицей страниц. Размер страницы 4096 байтов. Таблица страниц первого уровня (внешняя（外部）) содержит 8192 записи（条）. Определить（识别） размер каждой таблицы второго уровня.
    * 答案：
        Виртуальный адрес – это комбинация номера страницы первого уровня, номера страницы второго уровня и смещения в странице, всего 32 бита.
        4096 = 2^12, следовательно под смещение в странице отводится 12 бит.
        8192 = 2^13, следовательно под номер страницы первого уровня отводится 13 бит.
        Под номер страницы второго уровня остается 32-12-13=7 бит.
        Следовательно, размер каждой таблицы второго уровня равен 2^7=128 записей.

    5.  Пусть дан 32-разрядный компьютер, в котором реализована двухуровневая таблица страниц. Размер страницы 4096 байтов. Каждая таблица второго уровня содержит 256 записей. Сколько записей содержит «внешняя таблица страниц»?
    * 答案：2 ^ (32 – log 4096 – log 256) = 2 ^ (32 – 12 – 8) = 2 ^ 12 = 4096

16. Dijkstra信号量
    * 概念题，还比较好理解,Dijkstra是一位来自荷兰的大师的名字，他提出了这类信号量
    * 我们上课学的是IPC信号量，是Dijkstra信号量的一种实现形式

    1. Дать формальное описание семафора（信号量） Дейкстры（Dijkstra）, который может использоваться для реализации взаимного（互） исключения（斥）.
    * 答案：Дать определение семафора, у которого начальное и максимальное значение равно 1

    2. Дать формальное описание семафора Дейкстры, который может использоваться для реализации одновременного доступа к ресурсу не более 4-х процессов.
    * 答案：Дать определение семафора, у которого начальное и максимальное значение равно 4

    3. Привести（给出） схему（方案） взаимного исключения процессов с помощью двоичного（二进制） семафора Дейкстры.
    * 答案：Семафор в начальном состоянии（状态） должен быть открыт (=1). 
    Схема:
    P (закрыть семафор) – критическая секция（临界区） – V (открыть семафор)

    4. Привести схему взаимного исключения процессов с помощью семафоров IPC.
    * 答案：Семафор (semid) в начальном состоянии должен быть открыт (=1). 
    Схема:
    ```c
    struct sembuf P = {0, -1, 0};
    struct sembuf V = {0, 1, 0};
    semop(semid, &P, 1); //(закрыть семафор) 
    //– критическая секция（临界区） – 
    semop(semid, &V, 1); //(открыть семафор)
    ```
    * sembuf结构的三个数值分别表示 1.第i个信号量，2.对信号量的操作，3.指定操作时的行为标志，从这里可以看出P和V都是一个操作
    * 我们约定P是尝试获取一个信号量（wait操作，荷兰语：Proberen，实现为-1），V是释放一个信号量(Signal操作，荷兰语：Verhogen，实现为+1)
    * 图中P={0,-1,0}表示，对第0个信号量进行-1操作，并且没有任何特殊的行为标志
    * 调用P操作-尝试获取资源：如果资源不可以，则阻塞直到可用（也就是其他进程释放信号量）-进入临界区访问共享资源-调用V操作：释放信号量，离开临界区

    5. Можно ли реализовать семафор Дейкстры через обычную（常规的） целую переменную и активное（主动） ожидание（等待）, например:
    ```c
    int sem =1;
    while (sem == 0); // ждем пока семафор поднимут
    sem=0; // входим в критическую секцию
    //работаем с разделяемым ресурсом
    sem=1; // выходим из критической секции
    ```
    * 答案：
    Нет, отсутствует（没有） атомарность（原子性）: между проверкой（检查） и установкой（设置） семафора может произойти（发生） переключение（转换） на другой процес

    6. Дать формальное описание семафора Дейкстры, который может использоваться для реализации единовременного доступа（访问） к ресурсу（资源） не более чем 2-х процессов.
    * 答案：
    Дать определение семафора, у которого начальное и максимальное значение равно 2

    7. Дать описание операций, которые могут выполняться（执行） над семафором Дейкстры.
    * 答案：
    Атомарная операция down(S): проверяет значение семафора S. Если оно больше нуля(> 0), то уменьшает его на 1, иначе процесс блокируется(阻塞) (связанная（相关） с процессом операция down считается（被认为） незавершенной（未完成）).
    Атомарная операция up(S): увеличивает значение семафора на 1. Если в системе присутствуют（存在） процессы, блокированные ранее（先前） операцией down на этом семафоре, один из них разблокируется（解锁） и завершает выполнение операции down.

    8.  Дать формальное описание семафора Дейкстры, который может использоваться для реализации взаимного исключения. Какие средства（手段，工具） межпроцессного（进程之间的） взаимодействия（互动） (кроме собственно（本身） семафоров) могут быть использованы для реализации взаимного исключения и как?
    * 答案：
    Дать определение семафора, у которого начальное и максимальное значение равно 1.
    Каналы через блокировку на чтение（读取） из пустого（空的） канала.
    Очереди（队列） сообщений（消息） через блокировку на чтение сообщений（信息） нужного типа.
    Сигналы через блокировку на ожидании сигнала.

17. 文件系统中可以具有的块中最大文件大小是多少
    * 10个块，对引用块的引用，再加上对引用块的引用的引用，等等
    * 我还是没搞明白

    1. Дана файловая система, имеющая архитектуру（结构）,аналогичную（类似于） fs5. Пусть размер ссылки на блок файловой системы – 4 байта; размер блока 32 байта. Какой предельный размер файла в блоках могут иметь файлы в такой файловой системе (указать число)?
    * 答案：10+8+8^2+8^3 = 594

    5. Дана файловая система, архитектура которой аналогична fs5. Пусть размер ссылки на блок файловой системы – 4 байта; размер блока 64 байта. Найдите предельный размер файла в такой файловой системе (указать константное выражение) в байтах.
    * 答案：64 * (10+16+16^2+16^3)

    6. Дана файловая система, имеющая архитектуру,аналогичную fs5. Пусть размер ссылки на блок файловой системы – 8 байтов; размер блока 2048 байтов. Какой предельный размер файла в блоках могут иметь файлы в такой файловой системе (указать константное выражение)?
    * 答案：10+256+256^2+256^3

18. 页表，虚拟RAM和物理内存的关系计算
    * 看清楚要算的是位深度还是物理内存量，或者别的啥东西

    1. Пусть в некотором（某些） компьютере реализована страничная（页） организация памяти, таблица страниц операционной системы имеет размер 4096 записей（条目）. Размер страницы 512 байтов. Определите（确定） разрядность（位深度） виртуального（虚拟地址） адреса для данного случая.
    * 答案：21 разряд （log2(4096)+log2(512)=12+9=21）

    2. Пусть в некотором компьютере реализована страничная организация памяти с использование инвертированной（逆序，倒转） таблицы страниц, состоящей из 300 записей. Размер виртуальной страницы ОЗУ（RAM） 2048 байтов. Каков объем физической памяти этого компьютера?
    * 答案：300 х 2048 байтов （300页，一页2048字节乘起来就是）

    5. Пусть в некотором компьютере реализована страничная организация памяти, таблица страниц операционной системы имеет размер 2048 записей. Размер страницы 4096 байтов. Определите разрядность виртуального адреса для данного случая.
    * 答案：log 2048 + log 4096 = 23 разряда

19. 中断
    * 概念题

    1. Для каких целей（目标） в рассмотренной（考虑） в курсе модели обработки（处理） прерываний（中断） введена（介绍，引入） блокировка（阻塞） прерываний?
    * 答案：
    Для того, чтобы в момент сохранения точки и контекста（上下文） прерывания не пришло（到达） другое прерывание, и не произошла（发生） потеря（丢失） информации о точке первого прерывания.

    2. Всегда ли в устройствах（设备）, работающих по протоколу TCP/IP, поддерживаются（支持） все 4 уровня взаимодействия（互动，通讯） (протокола（协议）)? Ответ обосновать.
    * 答案：
    Нет, не всегда (например, в шлюзах（闸门，网关） реализованы только первые два уровня, поскольку（由于） они просто передают（传递） информацию, и уровни более высокого уровня представления（表示） в них не нужны).

    3. Чем отличаются длинные（长） и короткие（短） прерывания? Дать пример длинного прерывания.
    * 答案：
    При коротком（短） прерывании не происходит（发生） смена（变化） контекста выполняемого（正在执行的） процесса, поэтому достаточно（足够） только малого упрятывания（隐藏） информации о выполняемой（已完成的） программе (флаги, регистры процессора). 
    Длинное прерывание – от контроллера（控制器） прямого доступа в память

    4. Чем отличаются длинные и короткие прерывания? Дать пример короткого прерывания.
    * 答案：
    При коротком прерывании не происходит смена контекста выполняемого процесса, поэтому достаточно только малого упрятывания информации о выполняемой программе (флаги, регистры процессора). 
    Короткое прерывание – от клавиатуры.

    5. Для каких целей в рассмотренной в курсе модели обработки прерываний введена блокировка прерываний?В каком из средств межпроцессного взаимодействия（通信） используется（使用） (может быть использован（使用过）) похожий механизм（机制）?
    * 答案：
    Для того, чтобы в момент сохранения точки и контекста прерывания не пришло другое прерывание, и не произошла потеря информации о точке первого прерывания.
    Такой же механизм может использоваться при обработке（处理） сигналов – пока обрабатывается один сигнал, доставка других сигналов может быть заблокирована（阻止）.

20. 关于信号的代码输出
    * 注意管道引起的顺序变化（如果没有管道，那么什么顺序都可以，如果有，那么只有写之后才能读）
    * 对于控制进程的if-else后的部分，如果没有SIGKILL那么所有进程都会执行。

    6. Что будет выведено（输出） на экран? Если возможны несколько вариантов – привести все.
    Предполагается（假设）， что обращение（访问） к функции вывода на экран прорабатывает（处理） атомарно и без буферизации（缓冲）.Все системные вызовы прорабатывают успешно（成功）. Подключение заголовочных файлов опущено（省略）.
    ```c
    int main(){
        pid_t pid;
        int fd[2];
        int x = 3;
        pipe(fd);
        if( (pid = fork()) > 0 ) { 
            read(fd[0], &x, sizeof(int)); 
            kill(pid, SIGKILL); 
        } else { 
            printf("%d", x); x = 2; 
            write(fd[1], &x, sizeof(int)); x = 1;
        }
        printf("%d", x);
        return 0;
    }
    ```
    * 答案：32 либо 312 либо 321

    9. Что будет выведено на экран? Если возможны несколько вариантов – привести все.
    Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main() {
        pid_t pid;
        int fd[2];
        int x = 9;
        pipe(fd);
        if( (pid = fork()) > 0 ) { 
            printf("%d", x - 1);
            read(fd[0], &x, sizeof(int));
            kill(pid, SIGKILL);
            wait(NULL);
        } else { 
            x = 6;
            printf("%d", x);
            x = 3;
            write(fd[1], &x, sizeof(int));
            x = 7;
        }
        printf("%d", x);
        return 0;
    }
    ```
    Поясните свой ответ.
    * 答案：
    ```c
    863
    683

    8673
    6873

    6783
    ```


21. 程序输出，关于POSIX消息队列
    * 使用 msgctl 函数时，需要包含头文件 <sys/ipc.h> 和 <sys/msg.h>。
    * msg.type 是消息类型，这决定了是否被发送和接收
    * msg.data 是消息中的内容，msg.data[0]就是消息中的第一个字符
    * msgget(key_t key, int msgflg);,key 参数用于指定消息队列的键值，可以是 IPC_PRIVATE 或通过 ftok 函数生成的键值。msgflg 参数用于设置消息队列的权限和其他选项，可以与 IPC_CREAT 和 IPC_EXCL 等标志位进行或操作。
    * msgsnd(),msgsnd(msgId, &msg, 1, 0);第一个参数是消息队列的标识符，第二个参数是消息结构体的指针（其中包括了消息类型和数据），第三个是消息内容大小（单位为字节），第四个是控制消息发送操作的标志位（0表示消息会添加到末尾）
    * msgrcv(),msgrcv(msgId, &msg, 1, 2, 0);第一个参数是消息队列的标识符，第二个参数是消息结构体的指针，第三个是消息正文的最大长度（单位为字节），第四个是接受的消息类型（如果为0表示所有类型都接收，否则之），第五个是控制消息发送操作的标志位（和上面一样）
    * msgctl(int msgid,int cmd,struct msqid_ds *buf),第一个参数是消息队列的标识符，第二个参数操作的命令，第三个是一个指向 msqid_ds 结构体的指针，用于存储或返回消息队列的状态信息。具体作用取决于 cmd 参数的值。msqid_ds 结构体包含了消息队列的管理和状态信息，如权限、所有者、消息队列的大小等。可用的命令有：
        * IPC_RMID - 删除消息队列。当使用此命令时，buf 参数必须为 NULL。此命令会移除消息队列，所有在队列中的消息都会丢失。
        * IPC_STAT - 获取消息队列的状态信息。当使用此命令时，buf 必须指向一个 msqid_ds 结构体，该结构体在调用前会被清零，调用后会被填充消息队列的状态信息，如创建者、最后操作时间等。
        * IPC_SET - 设置消息队列的状态信息。当使用此命令时，buf 必须指向一个已经填充了新状态信息的 msqid_ds 结构体。通常，只有消息队列的所有者或者超级用户才能更改消息队列的状态。

    1. Что будет выведено（输出） на экран в результате работы фрагмента（片段） программы? Если возможны несколько вариантов – привести все.Предполагается（假设）, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    msgId – идентификатор（ID，标识符） существующей（现有的） пустой（消息） очереди（队列） сообщений（消息）.
    ```c
    struct {
        long type;
        char data[1];
    } msg;
    ……..
    msg.type = 1; msg.data[0] = 'a'; msgsnd(msgId, &msg, 1, 0);
    msg.type = 2; msg.data[0] = 'b'; msgsnd(msgId, &msg, 1, 0);
    msg.type = 2; msg.data[0] = 'c'; msgsnd(msgId, &msg, 1, 0);
    msg.type = 1; msg.data[0] = 'd'; msgsnd(msgId, &msg, 1, 0);
    msgrcv(msgId, &msg, 1, 2, 0); putchar(msg.data[0]); 
    msgrcv(msgId, &msg, 1, 0, 0); putchar(msg.data[0]);
    msgrcv(msgId, &msg, 1, 1, 0); putchar(msg.data[0]);
    ……
    ```
    * 答案：bad

    2. Что будет выведено на экран в результате работы фрагмента программы? Если возможны несколько вариантов – привести все.Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    msgId – идентификатор существующей пустой очереди сообщений.
    ```c
    struct {
        long type;
        char data[1];
        } msg;
    ……..
    msg.type = 1; msg.data[0] = '1'; msgsnd(msgId, &msg, 1, 0);
    msg.type = 2; msg.data[0] = '2'; msgsnd(msgId, &msg, 1, 0);
    msg.type = 2; msg.data[0] = 'a'; msgsnd(msgId, &msg, 1, 0);
    msg.type = 1; msg.data[0] = 'b'; msgsnd(msgId, &msg, 1, 0);
    msgrcv(msgId, &msg, 1, 2, 0); putchar(msg.data[0]); 
    msgrcv(msgId, &msg, 1, 0, 0); putchar(msg.data[0]);
    msgrcv(msgId, &msg, 1, 1, 0); putchar(msg.data[0]);
    ```
    * 答案：21b

    3.  Что будет выведено на экран в результате работы фрагмента программы? Если возможны несколько вариантов – привести все.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    msgId – идентификатор существующей пустой очереди сообщений.
    ```c
    struct {
        long type;
        char data[1];
    } msg;
    ……..
    msg.type = 1; msg.data[0] = 'x'; msgsnd(msgId, &msg, 1, 0);
    msg.type = 2; msg.data[0] = 'y'; msgsnd(msgId, &msg, 1, 0);
    msg.type = 2; msg.data[0] = 'z'; msgsnd(msgId, &msg, 1, 0);
    msg.type = 1; msg.data[0] = 't'; msgsnd(msgId, &msg, 1, 0);
    msgrcv(msgId, &msg, 1, 2, 0); write(1, msg.data[0], 1); 
    msgrcv(msgId, &msg, 1, 1, 0); write(1, msg.data[0], 1);
    msgrcv(msgId, &msg, 1, 0, 0); write(1, msg.data[0], 1);
    ……
    ```
    * 答案：yxz

22. 程序输出，关于fork和管道
    * 有什么好说的吗
    
    1. Что будет выведено на экран? Если возможны несколько вариантов– привести все. Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main(){
        char c;
        int fd[2], fd2[2];
        pipe(fd); pipe(fd2);
        if(fork() == 0) { 
            write(fd[1], &c, 1); 
            putchar('d'); 
            read(fd2[0], &c, 1); 
            putchar('b'); exit(0);
        }
        putchar('a'); read(fd[0], &c, 1); 
        putchar('c'); write(fd2[1], &c, 1); 
        wait(NULL);
        putchar('f'); return 0;
    }   
    ```
    * 答案：acdbf либо adcbf либо dacbf

    8. Что будет выведено на экран? Если возможны несколько вариантов – привести все. Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main() {
        char c = '1';
        int fd[2], fd2[2];
        pipe(fd); pipe(fd2);
        if(fork() == 0) { 
            write(fd[1], &c, 1);
            putchar('2');
            read(fd2[0], &c, 1);
            putchar('3');
            exit(0); 
        }
        putchar('4'); 
        read(fd[0], &c, 1);
        putchar('5');
        write(fd2[1], &c, 1);
        wait(NULL);
        putchar('6');
        return 0;
    }
    ```
    * 答案：
    ```c
    45236 
    либо
    24536
    либо
    42536
    ```

23. 关于信号量的代码，从列出的输出中选出不可能发生的选项
    * 信号量被初始化为多少，说明多少个进程可以同时进入临界区
    * op.sem_num = 0; op.sem_flg = 0; op.sem_op = -1; 就是前面提到过的sembuf结构体字段
    * 根据信号量阻塞的情况，我们可以得到结果

    1. Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.Вычеркните（删掉） варианты вывода, невозможные при выполнении фрагментов（片段） программ тремя（三个） параллельными（并行的） процессами (A,B,C):
    semId – идентификатор（标识符） массива семафоров, состоящего（由...组成） из 1 семафора. Массив проинициализирован（初始化） с помощью вызова: 
    ```c
    semctl(semId, 0, SETVAL, 2);
    ```

    Данный фрагмент выполняется двумя параллельными процессами (A и B):
    ```c
    struct sembuf op; op.sem_num = 0; op.sem_flg = 0; 
    op.sem_op = -1; semop(semId, &op, 1); putchar('1');
    putchar('2'); op.sem_op = 1; semop(semId, &op, 1);
    ```

    Данный фрагмент выполняется одним параллельным процессом С:
    ```c
    struct sembuf op; op.sem_num = 0; op.sem_flg = 0; 
    op.sem_op = -1; semop(semId, &op, 1); putchar('3');
    op.sem_op = 1; semop(semId, &op, 1);
    ```
    Варианты вывода:
    1) 12213
    2) 12123
    3) 11232
    4) 11322
    5) 11223
    6) 31212

    * 答案：
    Невозможные варианты вывода:
    1) 12213
    4) 11322

    * abbac - 这个序列是不可能的。考虑到信号量 semId 初始化为2，意味着可以有两个进程同时进入临界区。如果 X 或 Y 打印了 'ab'，那么在它们释放信号量之前，Z 无法进入临界区打印 'c'。因此，在一个完整的 'ab' 对之后，另一个 'a' 不能紧接着出现，除非第一个 'ab' 的进程已经完成了它的临界区操作并且 Z 已经完成其 'c' 的打印。所以 'abbac' 是不可能的，因为两个 'b' 之间的 'a' 意味着有第三个 'a' 在没有对应的 'b' 之前就出现了。
    * aacbb - 这个序列是不可能的，正如之前提到的，'c' 不应该打断 'a' 和 'b' 的对。如果 'c' 出现了，那么它应该是在 'ab' 对之间或之后。 


    3. Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.Вычеркните варианты вывода, невозможные при выполнении фрагментов программ тремя параллельными процессами (X,Y,Z):
    semId – идентификатор массива семафоров, состоящего из 1 семафора. Массив проинициализирован с помощью вызова: 
    ```c
    semctl(semId, 0, SETVAL, 2);
    ```
    Данный фрагмент выполняется двумя параллельными процессами (X и Y):
    ```c
    struct sembuf op; op.sem_num = 0; op.sem_flg = 0; 
    op.sem_op = -1; semop(semId, &op, 1); putchar('a');
    putchar('b'); op.sem_op = 1; semop(semId, &op, 1);
    ```
    Данный фрагмент выполняется одним параллельным процессом Z:
    ```c
    struct sembuf op; op.sem_num = 0; op.sem_flg = 0; 
    op.sem_op = -1; semop(semId, &op, 1); putchar('c');
    op.sem_op = 1; semop(semId, &op, 1);
    ```
    Варианты вывода:
    1) abbac
    2) ababc
    3) aabcb
    4) aacbb
    5) aabbc
    6) cabab

    * 答案：
    Невозможные варианты вывода:
    1) abbac
    4) aacbb

24. 另一类信号量的代码，写出可能出现的所有选项
    * 同样的注意阻塞带来的顺序可能性，看是否出现了不可能的组合

    2. Что будет выведено на экран? Если возможны несколько вариантов – привести все.Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    semId – идентификатор массива семафоров, состоящего из 1 семафора 
    Массив проинициализирован с помощью вызова: 
    ```c
    semctl(semId, 0, SETVAL, 8);
    ```
    Фрагмент программы выполняется 3-мя параллельными процессами:
    ```c
    struct sembuf op; op.sem_num = 0; op.sem_flg = 0;
    op.sem_op = -3; semop(semId, &op, 1);
    write(1, "1", 1); write(1, "2", 1);
    op.sem_op = 2; semop(semId, &op, 1);
    ```
    * 答案：
    Варианты:
    121212
    121122
    112122
    112212

    6. Какие средства（工具） синхронизации（同步） можно выбрать и какие действия вставить（插入） в эту программу, чтобы сначала напечаталось AВ, потом CD или DC (оба варианта должны быть возможны)?
    ```c
    int main(void) {
        if (fork()) {
            write(1, “A”, 1);
            write(1, “C”, 1);
            wait(NULL);
        } else {
            write(1, “B”, 1);
            write(1, “D”, 1);
        }
    }
    ```
    * 答案：
    Можно использовать семафор:
    ```c
    int main(void) {
        semaphore s = 0;
        if (fork()) {
            write(1, “A”, 1);
            up(&s, 1);
            down(&s, 2);
            write(1, “C”, 1);
            wait(NULL);
        } else {
            down(&s, 1);
            write(1, “B”, 1);
            up(&s, 2);
            write(1, “D”, 1);
        }
    }
    ```

    9. Опишите（描述） словесно（口头） все варианты вывода на экран.Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main()
    {
        int fd[2];
        char c[2];
        pipe(fd);
        write(fd[1], c, 2);
        fork();fork();fork();fork();
        read(fd[0], c, 1);
        write(1, "a", 1);
        write(1, "b", 1);
        write(fd[1], c, 1);
        wait(NULL);
        return 0;
    }
    ```
    * 答案：
    Будет выведена последовательность из a и b длиной в 32 символа, в которой содержится по 16 символов a и b. Любой префикс выводимого программой ответа будет начинаться с ‘a’, а разница между количеством ‘a’ и количеством ‘b’ в любом префиксе не меньше нуля и не больше двух.



25. 关于fork和管道的代码，列出所有可能输出
    * 我就不看了，你来看吧

    2. Что будет выведено на экран? Если возможны несколько вариантов – привести все.Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main() {
        int fd[2];
        char c[2] ="34";
        pipe(fd);
        write(fd[1], c, 2);
        if(fork()) fork();
        read(fd[0], c, 1);
        write(1, "1", 1);
        write(1, "2", 1);
        write(fd[1], c, 1);
        wait(NULL);
        return 0;
    }
    ```
    * 答案：
    Варианты:
    121212
    121122
    112122
    112212

    3. Что будет выведено на экран? Если возможны несколько вариантов – привести все.Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main(){
        int fd[2];
        char c[2] ="34";
        pipe(fd);
        write(fd[1], c, 2);
        if (fork())
        fork();
        fork(); fork();
        read(fd[0], c, 2);
        write(1, "a", 1);
        write(1, "b", 1);
        write(fd[1], c, 2);
        wait(NULL);
        return 0;
    }
    ```
    * 答案：
    Будет выведена последовательность пар ab длиной 12 (всего 24 символа)


26. 关于多次fork和管道的代码，列出所有可能输出
    * 画个图吧我觉得

    1. Что будет выведено на экран? Если возможны несколько вариантов – привести все.Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main()
    {
        int fd[2];
        pipe(fd);
        char x[] = "ba\n";
        if(fork()) { 
            puts(x + 1); write(fd[1], x, 1); 
            wait(NULL);
        } else { 
            write(fd[1], &x[1], 1); read(fd[0], x, 1); 
            read(fd[0], x+1, 1);
        }
        puts(x); return 0;
    }
    ```
    * 答案：
    a 
    ba 
    ba 
    либо
    a
    ab
    ba

    3. Что будет выведено на экран? Если возможны несколько вариантов – привести все.Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main() {
        int fd[2];
        pipe(fd);
        char x[] = "dc\n";
        if(fork()) { 
            puts(x + 1); 
            write(fd[1], x, 1); 
            wait(NULL);
        } else { 
            write(fd[1], &x[1], 1); 
            read(fd[0], x, 1); 
            read(fd[0], x+1, 1); 
        }
        puts(x); return 0;
    }
    ```
    * 答案：
    c
    dc
    либо
    c
    cd
    dc

27. 关于字符串，fork和管道的代码，描述进程会发生什么
    * 注意fd[2]只有在 pipe(fd)==0 之后才是管道，在这之前就是一个2个成员的int数组

    1. Описать, что произойдет（发生） с процессами и почему (все системные вызовы отрабатывают корректно – без отказов)
    ```c
    int main(int argc, char **argv) 
    {
        int fd[2];
        char c[2] = "ab";
        pipe(fd); 
        if(fork()) { /* процесс №1 */
            close (fd[0]);
            close (fd[1]);
        } else { /* процесс №2 */
            read(fd[0], c,1);
        }
    }
    ```
    * 答案：
    Процесс № 1: завершится. （将会完成）
    Процесс № 2: зависнет（冻结，阻塞）, т.к. в системе не будет закрыт дескриптор（描述符） записи в этот канал (дескриптор, который был унаследован（继承） процессом №2).

    3. Описать, что произойдет с процессами и почему (все системные вызовы отрабатывают корректно – без отказов)
    ```c
    int main(void) 
    {
        int fd[2];
        char c[] = "abc\n";
        if(fork() == 0) { /* процесс №1 */
            close (fd[0]);
            close (fd[1]);
        } else { /* процесс №2 */
            read(fd[0], &c, 2);
        }
    }
    ```
    * 答案：
    Поведение（行为） не определено（定义）, т.к. не инициализирован（初始化） массив fd.

    5. Описать, что произойдет с процессами и почему (все системные вызовы отрабатывают корректно – без отказов)
    ```c
    int main(int argc, char **argv){
        int fd[2];
        char c[2] = "ab";
        pipe(fd); 
        if(fork()) {/*процесс №1*/
            close (fd[0]);
            close (fd[1]);
            wait(NULL);
        } else {/*процесс №2*/
            read(fd[0],c,1);
            close(fd[1]);
        }
    }
    ```
    * 答案：
    Процесс № 2: зависнет（冻结）, т.к. в системе не будет закрыт дескриптор записи в этот канал (дескриптор, который был унаследован процессом №2).
    Процесс № 1: зависнет в ожидании завершения（完成） процесса № 2.


28. 关于文件，dup,lseek等的多进程代码,列出所有可能的输出并解释
    * open()的第一个参数接受打开的文件，第二个接受打开的标志，如O_RDONLY（只读），O_WRONLY（只写），O_RDWR（读写）
    * 还可以结合其他标志如 O_CREAT（如果文件不存在则创建）、O_EXCL（与 O_CREAT 一起使用，确保文件是新建的）、O_TRUNC（如果文件存在且为常规文件，则将其长度截断为0）等。
    * lseek()第一个参数接受要操作的文件描述符。第二个参数接受相对于 whence 参数所指定的位置偏移量。第三各参数指示从何处开始计算偏移量，可能的值有：
        * SEEK_SET：（从文件开头开始。）
        * SEEK_CUR：（从当前文件指针位置开始。）
        * SEEK_END：（从文件末尾开始。）
    * dup()函数用于复制一个已有的文件描述符，返回一个新的文件描述符，它指向同一个打开文件。两个描述符共享同一个文件偏移量和文件状态标志。
    * dup2();函数用于复制一个现有文件描述符到一个特定的文件描述符上，第一个参数是要复制的现有文件描述符，第二个参数是要成为副本的目标文件描述符。
    * 注意文件指针的位置（lseek函数会改变它），注意read函数也是会改变文件指针的位置的。

    1. Содержимое（内容） файла “1.txt” – строка «abcde». Что будет выведено на экран? Если возможны несколько вариантов – привести все.Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main()
    {
        char c = 'a';
        int fd; 
        fd = open("1.txt", O_RDONLY);
        if(fork()){
            int fd2 = open("1.txt", O_RDONLY);
            int fd3 = dup(fd);
            lseek(fd, 2, SEEK_CUR);
            wait(NULL);
            read(fd2, &c, 1); write(1, &c, 1);
            read(fd3, &c, 1); write(1, &c, 1); 
        }else{ 
            read(fd, &c, 1); write(1, &c, 1); 
        }
        return 0;
    }
    ```
    * 答案：
        Ответ: aad либо cad

        Два варианта порождаются（产生） за счет «гонок（赛车）» между lseek и read в «сыне». Сам вывод（结果） определяется（取决于） тем, что при «наследовании（继承）» и дублировании（复制） файлового дескриптора файловый указатель является общим（共同）, а при open создается новый.


    3. Содержимое файла “1.txt” – строка «123456». Что будет выведено на экран? Если возможны несколько вариантов – привести все.Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено.
    ```c
    int main(void)
    {
        char c = '0';
        int fd = open("1.txt", O_RDONLY);
        if(fork() == 0) {
            read(fd, &c, 1); write(1, &c, 1);
        } else {
            int fd2 = open("1.txt", O_RDONLY);
            int fd3 = dup(fd);
            lseek(fd, 2, SEEK_CUR);
            wait(NULL);
            read(fd2, &c, 1); write(1, &c, 1);
            read(fd3, &c, 1); write(1, &c, 1); 
        }
        return 0;
    }
    ```
    * 答案：
        Два варианта порождаются за счет «гонок» между lseek и read в «сыне». Сам вывод определяется тем, что при «наследовании» и дублировании файлового дескриптора файловый указатель является общим, а при open создается новый.
        Ответ:
        314 (lseek->read)
        114 (read -> lseek)


    8. Описать, что произойдет с процессами и почему (все системные вызовы отрабатывают атомарно и корректно – без отказов). Что будет выведено на экран? Если допустимы несколько вариантов вывода, приведите все.
    ```c
    int main(int argc, char **argv) 
    {
        int fd[2], buf = 10;
        pipe(fd);
        if(!fork()) {
            write (fd[1], &buf, sizeof(int)); buf++; 
            printf("%d\n", buf);
        } else { 
            while(read(fd[0], &buf, sizeof(int))) {
                buf--; printf("%d\n", buf);
            }
        }
        return 0;
    }
    ```
    * 答案：
        1. Сыновий процесс выполнит действия(操作) и завершится(结束).
        2. Родительский процесс считает информацию из канала, выведет на экран «9» и зависнет(冻结) (в нем не закрыт «пишуший(写)» дескриптор канала и read будет ожидать его закрытия).
        
        На экран будет выведено:
        11
        9
        ИЛИ
        9
        11

29. 文件系统和机械硬盘寻道的问题
    * 基本上是概念题

    1. В файловой системе используются битовые массивы для хранения информации о свободных（空闲的） и занятых（占用的） блоках. Написать на Си функцию, принимающую（接受） в качестве（作为） параметров（参数） указатель на начало этого битового массива (последовательность байтов), номер блока файловой системы (нумерация（编号） с нуля), максимально возможный номер блока и возвращающую（返回） статус занятости（占用状态） этого блока: 0 –свободен（空闲）, 1 занят（忙，被占用）, -1 – номер вне（外面，超出） диапазона（范围）.
    * 答案：
    ```c
        // Предположим, CHAR_BIT == 8
        int is_free(unsigned char *BitBlocks, unsigned Num, 
        unsigned Max_Num) {
            if (Num > Max_Num) {
                return -1;
            } else {
                return (BitBlocks[Num >> 3] >> (7 - (Num & 7u))) & 1;
            }
        }
    ```

    2. Головка（磁头） HDD находится на дорожке（轨道） 100. Нужно выполнить（表现） следующие запросы（需求） к дорожкам（轨道）:60, 5, 22, 83, 120, 71.Назвать（命名） последовательность запросов при использовании жадного（贪婪） алгоритма.
    * 答案：
        На каждом шаге выбираем ближайшую дорожку. 
        Получаем: 83, 71, 60, 22, 5, 120.

    3. Головка HDD находится на дорожке 90. Нужно выполнить следующие запросы к дорожкам:104, 20, 95, 56, 81, 3.Назвать последовательность запросов при использовании жадного алгоритма.
    * 答案：
        На каждом шаге выбираем ближайшую дорожку. 
        Получаем: 95, 104, 81, 56, 20, 3.

    4. Перечислите（列举） все ситуации, в которых системный вызов open(“/home/ira/dir/file”, O_RDONLY) может вернуть -1.
    * 答案：
        Замечание（注意）: не надо требовать（要求） перечислить ВСЕ ошибки, возникающие（发生） в ходе（步骤，进度） выполнения（执行） open, их в man – около 20. Достаточно назвать 3-4 различных ситуации, например:
        - файла /home/ira/dir/file нет
        - какая-то из директорий（目录） в пути /home/ira/dir/file отсутствует（丢失） или недоступна（不可用）
        - пользователь（用户） не имеет прав（权限） на чтение（读取） файла /home/ira/dir/file
        - в процессе нет доступных（可供选择的） файловых дескрипторов для открытия
        - превышен（超过） системный лимит（限制） на число открытых файлов
        - файл /home/ira/dir/file заблокирован（被阻止） для чтения др（其他人）.

    5. Перечислите все ситуации, в которых системный вызов execl(“/home/igor/dir/prog”) может вернуть -1.
    * 答案：
        Замечание: не надо требовать перечислить ВСЕ ошибки, возникающие в ходе выполнения exec, их в man – около 20. Достаточно назвать 3-4 различных ситуации, например:
        - файла /home/igor/dir/prog нет
        - какая-то из директорий в пути /home/igor/dir/ отсутствует или недоступна
        - пользователь не имеет прав на выполнение（执行） файла /home/igor/dir/prog
        - файл /home/igor/dir/prog не является исполняемым（可执行文件）
        - файл /home/igor/dir/prog является исполняемым, но имеет неверный（不正确的） формат（格式）
        - в процессе нет доступных файловых дескрипторов для открытия
        - нет ресурсов（资源） ядра（内核） для загрузки（加载） нового тела процесса
        - файл /home/igor/dir/prog заблокирован для чтения др.

    6. Пусть в некоторой ОС используется файловая система, использующая FAT. Для представления（表示） номера блока в системе используется беззнаковое целое. Написать функцию, которая по номеру начального блока файла (положительное（正的） целое число) определяет（确定） размер файла в блоках. Функция принимает（接收） в качестве параметров номер начального блока файла и указатель на область（区域） памяти, в которой находится FAT.
    * 答案：
        i-ая строка（行） таблицы FAT хранит（存储） информацию о состоянии i-ого блока файловой системы, а, кроме того, в ней указывается（指示，指向） номер следующего блока файла. Для получения списка（列表） блоков файловой системы, в которых хранится содержимое конкретного（特定的） файла, необходимо найти номер начального блока, а затем, последовательно обращаясь（寻址） к таблице размещения（安置） и извлекая（提取） из каждой записи номер следующего блока, дойти до ссылки（引用） на нулевую строку таблицы. Нулевая строка таблицы уже не относится（关注） к рассматриваемому（正在考虑的那一个） файлу.
        ```c
        int calculateSize(unsigned int num, unsigned int *fat)
        {
            int counter = 0;
            while (num != 0) {
                num = fat[num];
                counter++;
            }
            return counter;
        }
        ```

30. 调用函数时会访问文件描述符多少次？解释每一次是做什么
    * 基本上是概念题
    * 其实就说一层一层的往里面调用，从根目录开始一个文件夹调用一次

    1. Сколько раз система обратится（调用） к содержимому индексных дескрипторов при вызове: open("/dir/dir/file", O_RDONLY) ?Прокомментировать（评论）, почему? Считаем, что ни один из элементов пути к файлу не является символической ссылкой.
    * 答案：4 раза. 
        1 - дескриптор для / - чтобы найти дескриптор для файла каталога dir
        2 - дескриптор для /dir - чтобы найти дескриптор для файла каталога /dir/dir
        4 - дескриптор для /dir/dir/ - чтобы найти дескриптор для файла /dir/dir/ file
        5 - дескриптор для /dir/dir/file – чтобы проверить права доступа для этого файла и последующего чтения в память.

    2. Сколько раз система обратится к содержимому индексных дескрипторов при вызове: open("/dir1/dir2/dir3/file", O_RDONLY)?Прокомментировать, почему? Считаем, что ни один из элементов пути к файлу не является символической ссылкой.
    * 答案：5 раз. 
        1 - дескриптор для / - чтобы найти дескриптор для файла каталога dir1
        2 - дескриптор для /dir1 - чтобы найти дескриптор для файла каталога /dir1/dir2
        3 - дескриптор для /dir1/dir2 - чтобы найти дескриптор для файла каталога /dir1/dir2/dir3
        4 - дескриптор для /dir1/dir2/dir3 - чтобы найти дескриптор для файла /dir1/dir2/dir3/file
        5 - дескриптор для /dir1/dir2/dir3/file – чтобы проверить права доступа для этого файла и последующего чтения в память.

    3. Сколько раз система обратится к содержимому индексных дескрипторов при вызове: open("/dir1/file", O_RDONLY) ?Прокомментировать, почему? Считаем, что ни один из элементов пути к файлу не является символической ссылкой.
    * 答案：3 раза. 
        1 - дескриптор для / - чтобы найти дескриптор для файла каталога dir1
        2 - дескриптор для /dir1 - чтобы найти дескриптор для файла /dir1/file
        3 - дескриптор для /dir1/file – чтобы проверить права доступа для этого файла и последующего чтения в память.

    4. Сколько индексных дескрипторов нужно прочитать, чтобы загрузить файл /usr/exm/file.dat ?Считаем, что ни один из элементов пути к файлу не является символической ссылкой.
    * 答案：4

    5. Сколько индексных дескрипторов нужно прочитать, чтобы загрузить файл /home/program/dz/files/task.c ?Считаем, что ни один из элементов пути к файлу не является символической ссылкой.
    * 答案：6

